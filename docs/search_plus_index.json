{"./":{"url":"./","title":"简介","keywords":"","body":"简介 #btn{ background-color: #FF1D1D; margin-left: 20px; margin-right: 20px; -moz-border-radius: 12px; -webkit-border-radius: 12px; border-radius: 12px; -khtml-border-radius: 12px; vertical-align: middle; border: none; width: 35px; height: 35px; padding:1px; } .btn_bili{ background: url(\"image/button/bilibili.png\"); background-repeat: no-repeat; background-position: center center; background-size: 70% 70%; } .btn_github{ background: url(\"image/button/github.png\"); background-repeat: no-repeat; background-position: center center; background-size: 70% 70%; } .btn_book{ background: url(\"image/button/gitbook.png\"); background-repeat: no-repeat; background-position: center center; background-size: 80% 80%; } /* 鼠标悬停动画 */ #btn:hover{ width: 50px; height: 50px; background-color: #ff8080; transition-delay: 20ms; transition-duration: 100ms; transition-timing-function: ease-in-out; } .container{ background-color:#9F5C47; padding:20px; text-align:center; border-radius: 10px; margin-bottom: 5px; width:inherit; height:80px; /* 显示为盒子，为了居中 */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-pack: center; -webkit-box-align: center; display: -moz-box; -moz-box-orient: horizontal; -moz-box-pack: center; -moz-box-align: center; display: -o-box; -o-box-orient: horizontal; -o-box-pack: center; -o-box-align: center; display: -ms-box; -ms-box-orient: horizontal; -ms-box-pack: center; -ms-box-align: center; display: box; box-orient: horizontal; box-pack: center; box-align: center; } #btn_link{ /* 取消下划线 */ text-decoration: none; } 正在构建中。。。 "},"cpp/cpp.html":{"url":"cpp/cpp.html","title":"c++笔记","keywords":"","body":" C++笔记 一、基础概念 二、关键字 三、指针与引用 四、面向对象 五、内存 六、进程与线程 七、STL 八、数据结构 九、数组链表操作 十、目标查找 十一、二叉树 十二、动态规划 十三、单调栈 附录 工具库 "},"cpp/chapter/foundation.html":{"url":"cpp/chapter/foundation.html","title":"一、基础概念","keywords":"","body":"基础知识 1 c语言文件 头文件后缀名： .h 源文件后缀名： .c 2 c++文件 头文件后缀名： .h, .hpp, .hxx 源文件后缀名：.cpp, .cc, .cxx, .C .c++ .hpp: 声明和实现都有 .inl: 内联函数 3 内联函数   使用inline修饰的具体函数实现，非声明。编译期间对于编译器承认的inline函数，将会直接把代码拷贝到函数调用位置。 建议性质的关键字，只有简单的函数会被编译器承认。 默认地，类中定义的所有函数，除了虚函数之外，会隐式地或自动地当成内联函数; 虚函数也能用inline修饰，建议性质的。 泛型定义 4 重定义    #include会将头文件复制，同一个东西头文件实现一次，源文件实现一次就会触发重定义。 5 main函数 int argc : 传入参数个数，默认为1 const char * argv[] : 输入的参数列表 一个字符串数组 argv[0] : 被执行程序（.exe文件）所在的绝对路径。 6 编译器 gcc与g++进行文件编译时，会互相调用，但是编译.c文件除外；在链接时，不会互相调用。 预处理: -E，处理宏 编译:-S，生成汇编 汇编:-C，生成二进制 链接:-O，生成目标文件 7 定义与声明 定义：表示创建变量或分配存储单元 定义必须有，且只能出现一次 声明：说明变量的性质，但并不分配存储单元;在 链接 时，查找具体定义。 声明可以出现多次 变量： // 声明 extern int i; // 声明了未定义，但是不能重复声明 class Test{ public: static int a; }; // 定义 int Test::a = 0; // 声明又定义 int i; int i = 1; extern int i = 1; // 函数外部才能被初始化 源文件中的全局变量 `int a;` 形式，默认修饰符为 `extern`。 函数: 带有{ }的就是定义，否则就是声明。 8 模块化设计 模块即是一个.c文件和一个.h文件的结合，头文件(.h)中是对于该模块接口的声明，一般都用extern进行修饰； 供给其它模块调用的外部函数及全局变量需在.h中文件中冠以extern关键字声明； 模块内的函数和全局变量需在.c文件开头冠以static关键字声明； 永远不要在.h文件中定义全局变量！ 头文件中可以定义的实体，得有头文件保护，否则会重定义。 值在编译时就已知的 const 变量的定义可以放到头文件中 结构体，类的定义可以放到头文件中 inline 函数 9 泛型 template: typename , class作用一样。 泛型的定义和实现必须在同一个文件中。 class Car{ public: // 类型别名 typedef float Speed; // 内部类 class Wheel{ }; static float price; }; float Car::price = 10; // 定义泛型 template class PrivateCar{ public: // 定义变量 typename T::Speed v; typename T::Wheel wheels; float getPrice(){ T::price = 100; // 变量 return T::price; } }; "},"cpp/chapter/keyword.html":{"url":"cpp/chapter/keyword.html","title":"二、关键字","keywords":"","body":" 关键字 1. new/delete 编译器分配内存的关键字，会调用构造器与析构器。malloc/free为库函数实现。 [!note|style:flat] new/delete与malloc/free分配内存后，均没用初始化。 // 分配内存，没有初始化 int* a = new int[10]; // 分配内存，初始化 0 int* a = new int[10](); // 通过传值初始化 int* a = new int[10](另一个int[10]的数组); delete[] a; // 申请一个值的空间 int* b = new int(5); delete b; // malloc 函数申请空间，没有初始化 int* a = (int *) malloc(sizeof(int)*10); free(a); 2. const // 限定内容 const int*p; int const *p; // 限定指针 int* const p; // 都限定 const int* const p; 2.1 c const变量: 可以通过指针修改值，就是一个建议。 2.2 c++ 类成员函数后: 这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。 const函数内，只能调用const函数。 类成员函数前: 返回值是一个常量，不能修改，通常用来限定引用。 const变量: 编译器会将常量优化，放到符号表，取值会从表中直接获取，而不是去内存。通过指针修改值后，值不变。 添加关键字volatile，可以防止编译器优化，从内存取值。通过指针修改值后，值会变。 const对象: 只能访问const与static修饰的内容。 3. override   配合 virtual 关键字使用；修饰子类 override 函数。 4. volatile 避免优化、强制内存读取的顺序。 没有线程同步的语义 5. static 函数体内： 修饰的局部变量作用范围为该函数体，在内存只被分配一次，下次调用的时候维持了上次的值。 源文件全局：修饰的全局变量或函数，范围限制在声明它的模块内，不能被extern找到。 类中修饰成员变量: 表示该变量属于整个类所有，对类的所有对象只有一份拷贝。 在类里声明，到类外实现 类外全局处实现，不用static修饰 全对象共享 类中修饰成员函数: 表示该函数属于整个类所有，不接受this指针，只能访问类中的static成员变量。 类的里/外都能实现，类外实现省略static 6. extern \"C\"   会指示编译器这部分代码按C语言的进行编译，而不是C++的;能够正确实现C++代码调用其他C语言代码。 7. extern   使用include将另一个文件全部包含进去可以引用另一个文件中的变量，但是这样做的结果就是，被包含的文件中的所有的变量和方法都可以被这个文件使用，这样就变得不安全。如果只是希望一个文件使用另一个文件中的某个变量还是使用extern关键字更好。 源文件中的全局变量与函数定义，默认都能被extern找到。 8. friend   可以让外部函数或者外部类，访问私有类的私有属性与函数。 友元函数 定义在类外的普通函数 需要在类中声明 友元类: 友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。 不能被继承 两个类的关系是单向的 不可传递 8. 储存类型符 auto：所有局部变量默认的存储类， 对于C， 块语句中也可定义局部变量，形参也是。 register: 存储在寄存器中（只是建议，具体实现看编译器）。 static：局部修饰变量后改变了生存期;全局变量修饰后改变了作用域 extern：引入其他.C文件中已定义的非static全局变量;可以在函数的内外声明变量或者函数。 mutable：仅适用于类的对象成员变量，它允许const函数能对成员变量进行修改 9. cin 9.1. 简介 遇到 \\n 才会将写入内容加载到缓冲区 \\n 也算一个字符，会被加载到缓冲区 缓冲区为空时，cin 阻塞等待数据;一旦缓冲区中有数据，就触发 cin 去读取数据。 遇到EOF会结束。 [!tip|style:flat] 可用来循环读取值 while(cin >> value){} 9.2. 用法 1. cin >> 连续从键盘读取想要的数据，以空格、tab 、换行为分隔符。 char a; int b; float c; string cin>>a>>b>>c; 当 cin >> 从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin>> 会将其忽略并清除，继续读取下一个字符; 若缓冲区为空，则继续等待。但是如果读取成功，字符后面的 空白符号 是残留在缓冲区的，cin>> 不做处理。 不想略过空白字符，那就使用 noskipws 流控制。 cin >>的返回值为 cin ;当输入 EOF （windows:ctrl+z， Linux:ctrl+d）时， cin >> 会返回0。 int a; // 当输入 EOF 时，可以终止循环 while（cin >> a）{ } 2. cin.get() [!note|style:flat] 缓冲区没有东西时，会堵塞等待。 int get(); istream& get(char& var); istream& get( char* s, streamsize n ); istream& get( char* s, streamsize n, char delim); 读取字符 : #include using namespace std; int main() { char a; char b; a=cin.get(); cin.get(b); cout 从输入缓冲区读取单个字符时不忽略分隔符，直接将其读取。 读取行 istream& get(char* s, streamsize n) istream& get(char* s, size_t n, char delim) s ，接收字符串用的数组 n ，读取个数。实际读取个数为 n - 1 ，留了一个给 \\0 delim ，指定终止符 换行符(结束符)会被留在缓冲区， 但末尾其余空白符会被读取。 3. cin.getline（） 读取行 istream& getline(char* s, streamsize count); //默认以换行符结束 istream& getline(char* s, streamsize count, char delim); 换行符(结束符)会被清理掉， 但末尾其余空白符会被读取。 getline(cin,string,\"结束符\") 功能更强。传入的是 cin ，不是 stdin 9.3. cin 清空输入缓冲区 方法一 istream &ignore(streamsize num=1, int delim=EOF); 跳过输入流中 num 个字符，或遇到终止符 delim 结束（包括终止符）。 ignore() 会阻塞等待，最好别用 EOF 做终止符。 num : 可以设置一个很大的数 #include numeric_limits::max(); 方法二 fflush(stdin); 10. :: / : 10.1 :: 当局部变量与全局变量重名，可以修饰变量，访问全局变量。仅c++支持 int x; // Global x int main() { int x = 10; // Local x cout 在类之外定义函数 访问类的全局变量 class Test { public: static int x; }; int Test::x = 1; void main(){ Test::x; } 如果有多个继承，父类变量名重名，子类可以做区分。 两个命名空间重命名 访问内部类 #include using namespace std; class outside { public: int x; class inside { public: int x; static int y; int foo(); }; }; int outside::inside::y = 5; int main(){ outside A; outside::inside B; } 10.2 : foreach for(int item:vector){ } 继承 参数初始化列表 class Father{ public: Father(){ cout 10.3 参数初始化列表 初始化父类的构造器 初始化const变量 初始化var &引用变量 class Father{ public: Father(){ cout 11. include #include<> :只从从标准库文件目录下搜索，对于标准库文件搜索效率快。 #include\"\" :首先从用户工作目录下开始搜索，对于自定义文件搜索比较快，然后搜索标准库。 12. type-3 12.1. 总结type-3 名称 作用 注意 typedef 给变量A赋予一个别名B 1)A当前作用域可以访问的 2)B只在当前作用域有效 typeid() 获取类型信息，也就是对象原始模板的信息 泛型 typename 1）声明泛型类型； 2）声明泛型内嵌类型 下面解释 12.2. typeid() // 查看类型 typedef int FUCK; int var; const type_info & infoInt = typeid(int); const type_info & infoDef = typeid(FUCK); const type_info & infoVar = typeid(var); // 查看信息 info.name(); // 类型原始模板的名称 info.hash_code(); // 类型原始模板的哈希码 // 查看两个类型是否一样 if(infoInt == infoDef) [!note|style:flat] 1 infoInt,infoDef,infoVar都是一样的，他们的原始模板都是int。 2 泛型识别类型 template void print(T& a){ if(typeid(a) == typeid(int)){ cout 3 无法确定继承原始类型，输出为Father；s被首先Father静绑定了。 class Father{}; class Son : public Father{}; int main(){ Father * s = new Son(); cout 12.3. typename 声明泛型类型 // 泛型 template class Test{ public: void print(const T & a){ cout test; test.print(10); return 0; } [!note|style:flat] Test test;是在编译时确定，属于静态绑定。 声明泛型内嵌类型 泛型：大前提 内嵌：在类的内部定义类型。 class Car{ public: // 类型别名 typedef float Speed; // 内部类 class Wheel{ }; }; 当使用泛型的内嵌类型定义变量时，需要利用typename进行说明，否则编译器不知道这个是类型还是static变量。 class Car{ public: // 类型别名 typedef float Speed; // 内部类 class Wheel{ }; static float price; }; template class PrivateCar{ public: // 定义变量 typename T::Speed v; typename T::Wheel wheels; float getPrice(){ // 变量 return T::price; } }; [!note|style:flat] 不用typename的列外情况 template class Derived: public Base::内部类型 { Derived(int x) : Base::内部类型(x) { ... } } 13 private/protected/public 13.1 类的内部对外 [!note] 默认修饰为private 修饰成员 private protected public 外部能否访问 不行 不行 可以 13.2 继承 [!note] 默认继承为private 1. 子类内部对父类的访问 修饰父类成员 private protected public 子类能否访问 不行 可以 可以 [!note|style:flat] 继承限定对子类访问父类，没有一丢丢的影响，访问权限和上面一样。 2. 子类的父类成员对外 修饰继承 private protected public 子类中的父类成员 public变private protected变private public变protected 保持原样 "},"cpp/chapter/point_reference.html":{"url":"cpp/chapter/point_reference.html","title":"三、指针与引用","keywords":"","body":" 指针与引用 1 指针与引用 储存 初始化 二次赋值 形式 指针 有储存空间 NULL 可以 类名 * 引用 无空间，别名 已有的对象 不行 类名 & [!note|style:flat] c语言没有引用机制，是靠c++扩展实现。 2 对象与类 描述 储存 类 模板，包括属性和行为 无 对象 类的实例化，主要是数据的集合 主要只储存了属性，储存位置看具体情况 ; 函数放代码段，所有对象通用 3 智能指针   通过库函数，管理对象指针。 std::auto_ptr : 废弃 unique_ptr: 对象只能一个指针持有。 // 初始化赋值 std::unique_ptr p1(new int(5)); // 移交所有权，p1将变无效 std::unique_ptr p2 = std::move(p1); // 滞后赋值 unique_ptr p3; p3 = unique_ptr(new string (\"You\")); shared_ptr: 多个指针指向相同的对象。内部会有一个指向计数器，当计数器变为0时，系统就会对这个对象进行销毁，线程安全。 // make_shared生成 std::shared_ptr p1 = std::make_shared(10); // 拷贝赋值 std::shared_ptr p2; p2 = p1; weak_ptr: 没有重载operator*和->，用于防止shared_ptr循环引用。 4 野指针   野指针不是NULL指针，是未初始化或者未清零的指针，在程序中乱指。 指针变量没有被初始化 指针指向的内存被释放了，但是指针没有置NULL 指针越界 5 指针与数组 5.1 关系 二次修改 参与运算 sizeof() 指针 可以 可以 指针的字节 数组 不行 可以 声明空间的字节 5.2 数组 [!note|style:flat] 当定义了char s[10];时，s的真实类型应该为char * const s;，所以s不可修改。 在「形参」中，使用type name[] 与 type name[10]的形式接收数组，都会退化为type * name的形式，即name是当作指针处理了。 5.3 数组稀奇古怪的初始化方式 方式 说明 注意 int a[10]; 局部变量：未初始化； 全局变量：初始化为0；static修饰：初始化为0 int a[10] = {0} 肯定初始化为0。 int a[10] = {1,2,4} 前三个按照设置初始化，后面全是0 int a[10] = {1,2,4,} 编译通过 只能多写一个, 凸(▔皿▔╬) int a[3] = {1,2,4,} 编译通过 凸(▔皿▔╬) int a[3] = {1,2,3,4} 编译报错 {}写入的初始值个数不能大于数组声明值 const int N = 10;int n[N]; 编译通过 非const的N编译不通过 #define N 10; int n[N]; 编译通过 5.4 字符数组长度的计算 char str[20] = \"fuck you\"; // 计算字节数 sizeof(str); // 计算字符串的长度 strlen(str); "},"cpp/chapter/oop.html":{"url":"cpp/chapter/oop.html","title":"四、面向对象","keywords":"","body":" 面向对象 1 重载，重写，重定义 重载 overload: 同一个类中、函数名字相同、传参类型与数目不同。 覆盖 override: 实现父类virtual修饰函数，函数定义完全一样。覆盖了父类的虚函数。 重写 overwrite: 重定义父类函数，会屏蔽父类所有同名函数。 [!note|style:flat] 函数名相同就会屏蔽父类同名函数 注 : 用户能定义自己的C语言库函数，连接器在连接时自动使用这些新的功能函数。这个过程叫做重定向C语言库函数。 2 虚函数 虚函数实现 带有虚函数的类都会持有一个虚函数表 继承带有虚函数父类的子类，会复制一份父类虚函数表，并根据自身实现情况修改虚函数表 继承多个有虚函数表的子类，会维护所有的父类虚函数表 实例化的对象，会持有一个指向虚函数表的指针 虚函数/纯虚函数 子类实现后算overwrite 虚函数: virtual修饰，父类实现 纯虚函数: virtual修饰，父类不实现，后面可有 = 0，纯虚函数的类为抽象类。 [!note|style:flat] 虚函数是动绑定，运行时确定。 3 继承 当私有继承和保护继承时，父类指针(引用)无法指向子类。默认为私有继承。防止多重继承，出现属性多次定义，继承时，还要使用 virtual 进行修饰。 在子类中均存在但不可访问: 公有继承基类的private 保护继承中基类的private 私有继承中基类的private和protected和public， 4 重载/多态 多态: 父类与子类之间，父类可以接收不同子类，产生不同的行为。 virtual 修饰函数的 override：父类调用子类的实现。 该方式才实现多态。 无 virtual 修饰函数的 overwrite：父类调用父类的实现。 重载: 一个类里，同一名字的不同方法。 5 构造/析构函数 构造函数 不声明为虚函数 先父类，后子类 默认构造函数，即无参构造函数。 析构函数 要声明为虚函数; 通过多态析构子对象时，才能正确调用子类析构 先子类，再父类 6 静绑定与动绑定 静态类型：对象在声明时的类型，在编译期既已确定； 动态类型：通常是指针或引用所指对象的类型，是在运行期决定的； /** * A 类是声明，是obj的静态类型 * B 类是具体实例，是obj的动态类型 */ A* obj = new B(); 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期； 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；可以进行二次修改。 A* obj = NULL; obj->fcn();   上面的函数也是能正常运行的，因为obj在编译时静绑定。 7 构造函数 普通构造函数: 不能以本类的对象作为唯一参数 默认拷贝构造函数: 对源对象的逐个字节的复制，成员变量和源对象相同，由编译器自动生成 拷贝构造函数：构造函数的一种，只有一个本类的引用的参数，用不用const修饰都一样。 调用拷贝构造函数，不调用普通构造: 一个对象去初始化同类的另一个对象，赋值不会触发。 A a; // 初始化 A b = a; A c(a); // 赋值 b = a; 作为形参的对象，是用复制构造函数初始化的。直接传递对象，传过去的值，取决于构造函数的实现。 return 语句所返回的对象 8 动多态与静多态 实现方式 确定时间 动多态 继承与overwrite 运行时 静多态 泛型 编译 "},"cpp/chapter/memory.html":{"url":"cpp/chapter/memory.html","title":"五、内存","keywords":"","body":" 内存 1 代码内存分布 内存空间 存放内容 读写权限 内核空间 操作系统运行的内存空间。栈，堆。。齐全 应用程序不能直接操作 栈 函数局部变量，形参 读/写 堆 new/malloc申请空间 读/写 全局的数据空间 全局变量，static变量。包括初始化化的（data），未初始化的（bss）。 读写 只读数据段 \"fuck you\"等字符串常量 读 代码段 程序代码最终的指令集 读 3 内存泄露/栈溢出 内存泄露: 堆使用了，没清空，内存大量浪费 栈溢出: 使劲增加局部变量，栈用完了 4 字符存储编码 ASCII 码: 使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。 BCD码: （Binary-Coded Decimal‎）亦称二进码十进数或二-十进制代码。用4位二进制数来表示1个十进制数中的0~9这10个数码。 内码: 指汉字系统中使用的二进制字符编码。 5 字节对齐 5.1 介绍 1. 概念 内存空间按照字节划分，在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。 2. 原因 不同硬件平台对存储空间的处理上存在很大的不同。某些平台对特定类型的数据只能从特定地址开始存取，不能任意存放数据。 不按照平台要求对数据存放进行对齐，会带来存取效率上的损失。例如：一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问。 说白了就是为了CPU读写数据时，统一规则，能一大块一大块的拿，节约时间。 5.2 字节对齐计算 1. 字节对齐值 [!note] 数据类型「自身对齐值」：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。 结构体或类的「自身对齐值」：max(成员中自身对齐值) 指定对齐值：#pragma pack (对齐值) 结构体和类的「有效对齐值」：min{类，结构体自身对齐值，当前指定的pack值}。 数据成员的「有效对齐值」：min{成员自身对齐值，当前指定的pack值} 默认对齐值 ：64位，8字节；32位，4字节。 2. 字节对齐准则 [!warning|style:flat] 有效对齐值N最终决定数据存放地址方式。表示「对齐在N上」，即存放的起始地址满足 起始地址 % N == 0 数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。 类，结构体的成员变量要对齐存放 结构体本身也要根据自身的「有效对齐值」圆整， 即结构体成员变量占用总长度为结构体「有效对齐值」的整数倍，不足也要补足。 3. 储存字节计算 #pragma pack() struct TestA{ char ch; int i; double d; const char cch; }; struct TestB{ char chb; struct TestA a; int ib; }; #pragma pack() // 缺省，恢复默认的对齐字节 int main(void){ struct TestB b; printf(\"amount: %d\\n\",sizeof(b)); printf(\"b.a: %d\\n\", (unsigned int)(void*)&b.a - (unsigned int)(void*)&b); printf(\"b.a.ch: %d\\n\", (unsigned int)(void*)&b.a.ch - (unsigned int)(void*)&b); printf(\"b.a.i: %d\\n\", (unsigned int)(void*)&b.a.i - (unsigned int)(void*)&b); printf(\"b.a.d: %d\\n\", (unsigned int)(void*)&b.a.d - (unsigned int)(void*)&b); printf(\"b.a.cch: %d\\n\", (unsigned int)(void*)&b.a.cch - (unsigned int)(void*)&b); printf(\"b.ib: %d\\n\", (unsigned int)(void*)&b.ib - (unsigned int)(void*)&b); return 0; } triangle@DESKTOP-RDTVBUO:/mnt/c/Users/GOD/Desktop/test/testcpp./a.outamount:40b.a:8b.a.ch:8b.a.i:12b.a.d:16b.a.cch:24b.ib:32triangle@DESKTOP−RDTVBUO:/mnt/c/Users/GOD/Desktop/test/testcpp ./a.out \r amount: 40\r b.a: 8\r b.a.ch: 8\r b.a.i: 12\r b.a.d: 16\r b.a.cch: 24\r b.ib: 32\r triangle@DESKTOP-RDTVBUO:/mnt/c/Users/GOD/Desktop/test/testcpp./a.outamount:40b.a:8b.a.ch:8b.a.i:12b.a.d:16b.a.cch:24b.ib:32triangle@DESKTOP−RDTVBUO:/mnt/c/Users/GOD/Desktop/test/testcpp 对TestB的储存结构进行说明： 1. 64位系统，默认对齐字节8； 2. char chb：char的自身对齐值min{1,8}，所以存储地址首地址0 % 1 == 0成立。 3. TestA a：double d;字节数最大，所以其「自身对齐值」为8，有效对齐值为min{8,8}，存储地址首地址 8 % 8 == 0 成立。 ===开始对TestA a内部字节8 ~ 31进行划分。=== 1. char ch;：就按照TestA a首地址往下存。 2. int i;：int的自身对齐值min{4,8}，所以存储地址首地址12 % 4 == 0成立。 3. double d;：double的自身对齐值min{8,8}，所以存储地址首地址16 % 8 == 0成立。 4. const char cch;：char的自身对齐值min{1,8}，所以存储地址首地址24 % 1 == 0成立。 5. 由于TestA a的「有效对齐值」为 min(8,8) ，根据「圆整准则」TestA a 的大小必须为 n*8 ，所以最后的 25 ~ 31 为编译器填充。 ===对TestB进行最后圆整收尾=== 1. 对于TestB而言成员最大的对齐值是TestA a ，「有效对齐值」为 min(8,8) ，所以TestB 的大小必须为 n*8 ，最后进行了 36 ~ 39 的填充。 4. # pragma pack() [!note] # pragma pack(对齐值):可以重新定义默认的对齐字节值，计算方法就是3.中的默认值替换掉，然后同上计算。 对齐值只能为 2n2^n2n 。 # pragma pack(): 缺省，表示使用默认。 # pragma pack(push): 将当前对齐字节值保存 # pragma pack(pop): 将保存的对齐字节值弹出 5.3 字节对齐的隐患 1. 问题 // 案列一 int main(void){ unsigned int i = 0x12345678; unsigned char *p = (unsigned char *)&i; *p = 0x00; unsigned short *p1 = (unsigned short *)(p+1); return 0; } // 案列二 void Func(struct B *p2){ //Code } [!note|style:flat] 案列一：p1访问内存数值时，由于指向为奇数，对于32位会降低速度，对于特殊CPU则会异常。 案列二：p2如果是跨CPU访问，对齐要求不同，也会导致异常。 2. 解决方案 [!tip|style:flat] 对于案列二，可以选择修改对齐方式，然后重新赋值，让编译器解决。 #pragma pack(对齐值) void Func(struct B *p){ struct B tData; memmove(&tData, p, sizeof(struct B)); //此后可安全访问tData.a，因为编译器已将tData分配在正确的起始地址上 } 规划好字节排序： 同一类型尽量放一起 默认对齐字节整数倍大小的紧凑放最前 接着放能够凑成默认对齐字节大小的 不够默认对齐字节的放最后，并添加几个填充字符。 typedef struct tag_T_MSG{ // 默认对齐字节大小 int ParaA; int ParaB; // 凑默认对齐字节大小 short ParaC； char ParaD; //填充字节 char Pad; }T_MSG; 5.4 默认对齐字节的由来 1. 内存的结构 一个内存是由若干个「黑色的内存颗粒」构成；一个内存颗粒叫做一个「chip」；每个「chip」内部，是由8个「bank」组成的；每一个「bank」是一个二维平面上的矩阵，每一个元素中都是保存了1 byte，也就是8 bit。 2. 内存地址 内存地址编号： 一个地址编号对应一个字节，对于地址0x0000-0x0007地址，是在第一个「chip」上，是由重叠的8个「bank」相同位置上的元素从bank0 ~ bank7进行编号，8个「bank」是可以并行工作，加快读写速度。 8个「bank」： 64位cpu对内存的一次操作只能操作8 byte，因为64位cpu的寄存器是64位的，只能放8 * 8 bit的值。 3. 字节对齐默认值 [!note|style:flat] 64位的cpu，默认对齐字节为8， 这就能保证，小于等于8字节的数据存储位置，是cpu能一次操作就能成功获取完毕的。 假如: 你指定要获取的是0x0005 ~ 0x0009的数据：内存只好先工作一次把0x0000-0x0007取出来，然后再把0x0008-0x0000f取出来，最后再把两次的结果合并，把最终结果返回。 同理32位的cpu默认对齐字节位4，因为32位cpu的寄存器是32位的。 6 类/结构体的内存分布 6.1 类 一个类在内存中的组成： 若有virtual方法：第一个为vptr，所占字节数根据操作系统来：64位：8 byte，32位：4 byte。 非static变量 ，static变量在静态区。 const变量也在里面，虽然编译器会对常量进行优化放到常量表，但是根还在这儿。 对象变量指向第一个内存位置的地址 属性存放顺序与定义顺序一样 6.2 子类 [!note] 父类的若有vptr 就放第一个， 接着是父类的非static属性 最后放子类的属性 防止多重继承，出现属性多次定义，继承时，使用 virtual 进行修饰。 6.3 结构体 与类一样。唯一不同点，就是没有vptr。 6.4 字节计算 类：sizeof(vptr) + 5.2的结果；sizeof(vptr)由操作系统定，64位，8 byte；32位，4 byte 结构体：5.2的结果 在64位操作系统，sizeof(TestB)的大小为24。 class TestA{ public: const int b; virtual void fcn(){} }; class TestB{ public: int c; TestA a; }; 7 对象与类 描述 储存 类 模板，包括属性和行为 无 对象 类的实例化，主要是数据的集合 主要只储存了属性，储存位置看具体情况 ; 函数放代码段，所有对象通用 [!warning|style:flat] 类的概念没有占用内存，但是sizeof(类名)是有值的，等于sizeof(实列)计算结果。 8 代码地址 运行时地址起始位置：它芯片公司指定的一开始运行代码的位置。 运行地址: 就在从运行时地址起始位置（包括起始位置）往后排都是运行时地址。(程序代码被搬过来执行) 链接地址起始位置：链接脚本设定，这个位置在程序链接之后，就会确定下来。(用来计算偏移量的伪地址，之后重定向) 链接地址: 就是从链接地址起始位置（包括起始位置）往后排都是链接地址。(类似汇编地址) 加载地址: 从flash的那个地方开始读取程序，加载内存中去。 存储地址: 程序存储在哪儿的。 "},"cpp/chapter/process.html":{"url":"cpp/chapter/process.html","title":"六、进程与线程","keywords":"","body":" 进程与线程 1 进程 1.1. 创建   创建的是原进程的子进程，子进程会复制父进程的PCB(进程控制块)，二者之间代码共享，数据独有，拥有各自的进程虚拟地址空间。 #include pid_t fork(void); 写时拷贝技术  子进程创建后，与父进程映射访问同一块物理内存，当父或子进程对值进行修改时，会给子进程重新在物理内存中开辟一块空间，并将数据拷贝过去。 pid_t: 创建子进程失败，会返回-1; 创建子进程成功，父进程返回pid号，子进程返回0。 1.2. 终止 正常终止 main函数返回 调用exit函数: status 可以通过 wait（int *status） 接收; 会刷新缓冲 #include void exit(int status); 调用_exit函数: status 可以通过 wait（int *status） 接收; 不会刷新缓冲 #include void _exit(int status); 异常退出 Ctrl+C 被信号终止 1.3. 等待   如果子进程先于父进程退出，而父进程并没有关心子进程的退出状况，从而无法回收子进程的资源，就会导致子进程变成僵尸进程。进程等待的作用就是父进程对子进程收尸！父进程通过进程等待的方式，回收子进程的资源，获取子进程的退出状态。 wait #include #include pid_t wait(int *status); 利用阻塞，等待子进程退出。 一次只能等待一个 pid: 成功，子进程的pid; 失败(没有子进程)，返回-1; status: 进程退出信息 waitpid //头文件同wait的头文件 pid_t waitpid(pid_t pid, int *status, int options); 返回值: 等待成功，返回pid options为WNOHANG时，没有等待到子进程，马上退出不阻塞，返回0 出错则返回-1 pid: -1: 随便等待一个进程 pid号: 明确指定一个进程等待 options: 0: 阻塞等待，等待到一个就退出 WNOHANG: 没有等待到子进程，马上退出不阻塞，返回0 1.4. 进程退出信息status 低16位存放信息，高16位不用 高8位 : 退出码， exit 的传入值或者 return 值 (status >> 8) & 0xFF; 低8位 : 异常退出信息 第7位: core dump标志位;0，不产生;1，产生 (status >> 7) & 0x1; 低7位: 子进程是否异常退出;0，正常;非0，终止的信号 status & 0x7F; 2 进程状态 R (running): PCB被放入CPU的可执行队列中;CPU上执行的RUNNING状态、而将可执行但是尚未被调度执行的READY状态 S (sleeping): 睡眠状态，PCB被放入等待队列，可以通过中断唤醒。 D (disk sleep):睡眠状态，不能中断被唤醒。内核的某些处理流程是不能被打断的。用来保护进程。 T (stopped): SIGSTOP信号让进程进入暂停，SIGCONT信号能将进程恢复。 t (tracing stop): 在被追踪时，进程暂停;典型应用就是 gdb断点 。调试进程退出，被调试的进程才能恢复TASK_RUNNING状态。 Z (zombie): 进程退出后，PCB没有被回收。父进程没有对子进程收尸，就只能等父进程退出后，让爷进程来统一收尸。 X (dead): 马上会被彻底销毁 3 进程状态变化 `R`变非`R`状态。 非`R`变`R`状态 "},"cpp/chapter/stl.html":{"url":"cpp/chapter/stl.html","title":"七、STL","keywords":"","body":" STL 1 简介   STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。 数据结构和算法的分离 不是面向对象的 STL库的实现包含了「泛型函数」和 「泛型类」； STL算法的实现只包含了「泛型函数」 主要构成有六大组件: 容器（Container） 迭代器（Iterator） 算法（Algorithm） 仿函数（Functor） 适配器（Adaptor） 分配器（allocator） 2 容器（Container） 序列式容器（Sequence containers） Vector: 动态数组 Deque: 双端队列，是一种具有队列和栈的性质的数据结构。元素可以从两端弹出，其限定插入和删除操作在表的两端进行。 List: 双向链表 关联式容器（Associated containers) Set/Multiset: Set内的相同数值的元素只能出现一次; Multisets内可包含多个数值相同的元素。 Map/Multimap: map只允许key唯一；multimap中key可以重复使用； [!note|style:flat] set map multiset multimap 通过红黑实现，无序 unorder_map unorder_set 通过哈希表实现。 3 分配器 容器类自动申请和释放内存，无需new和delete操作。 4 迭代器 遍历数据用的。 支持运算符: *;+＋;＝＝;！＝;＝ 。 指针操作 Container c; Container::iterator it; for(it=c.begin();it!=c.end();it++){ // vector 获取值 *it; // map 获取键值对 it->first; it->second; } 带迭代器的容器遍历 // 只读 for(auto item:containers){ } // 可修改 能修改的值 for(auto& item:containers){ } 5 算法 1. 头文件   算法部分主要由头文件，和组成。 : 由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。 : 只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。 : 中则定义了一些模板类，用以声明函数对象。 2. 常用算法    STL常用算法 6 仿函数    钩子函数，可以当参数传递，让具体算法进行调用。 系统定义好的仿函数: 函数指针实现 仿函数实现: 定义一个简单的类 实现 operator() 操作符，本质上就定义了一个符号函数。 #include #include #include class Compare{ public: bool operator()(int a,int b){ return a > b; } }; int main(int argn,const char* args[]){ vector vec(5,1); vec[0] = 2; vec[1] = 1; vec[2] = 9; vec[3] = 3; vec[4] = 1; // 排序算法 sort(vec.begin(),vec.end(),Compare()); // 实际的函数调用 bool flag = Compare()(10,12); } [!note|style:flat] 注意： Compare()是定义了一个临时对象，作为参数传递给了 sort()；若sort()没有采用引用传递，则对象将是值传递。 7 容器适配器   对基础容器进行功能扩展，标准库提供了三种顺序容器适配器: queue(FIFO队列) stack(栈) priority_queue(优先级队列) 容器 头文件 默认容器 可选容器 说明 queue deque list、deque 基础容器必须提供push_front()运算 priority_queue vector vector、deque 基础容器必须提供随机访问功能 stack deque vector、list、deque "},"cpp/chapter/dataStruction.html":{"url":"cpp/chapter/dataStruction.html","title":"八、数据结构","keywords":"","body":" 数据结构 1 字符串 1.1 c风格 字符串结尾标志为 \\0 \" \" : 自带 \\0 strcpy，strncpy 不会在末尾加 \\0，dest还得手动加终止 strcat : 会自动加 \\0 #include // 创建 char str[] = \"RUNOOB\"; char *str = \"fuck you\"; char str[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\\0'}; // 拷贝字符串 strcpy(char *dest, const char *src); // 将src拷贝到dest，拷贝以 \\0 作终止; char *strncpy(char *dest, const char *src, size_t n); // n指定长度，更安全 // 拼接字符串 char *strcat(char *dest, const char *src); // 往dest上加字符串 // 字符串长度 strlen(str); // \\0 终止 // 比较字符串 int strcmp(const char *s1, const char *s2); // 相同返回 0 // 查找 char *strchr(const char *str, int c); //返回第一个字符位置，没有返回NULL char *strstr(const char *haystack, const char *needle); // 返回第一个字符串位置，没有返回NULL 1.2. c++字符串 string 是一个对象 string 的结尾没有结束标志 \\0 == 可以用来判断字符串是否相同 #include // 创建 string str; // s1的值为NULL string str = \"c plus plus\"; string str(c风格); // 字符串长度 str.length(); // 转c风格 str.c_str(); // 访问字符 str[i]; // 数字转字符串 string to_string(int value); string to_string(long value); string to_string(double value); // 字符转数字 atoi(const char*); stoi(const string&); strtoi(const char *); // 插入 string& insert (size_t pos, const string& str); // 删除 string& erase (size_t pos = 0, size_t len = npos); // 获取子串 string substr (size_t pos = 0, size_t len = npos) const; // 查找 返回第一个找到的位置，没找到返回一个无穷数 size_t find (const string& str, size_t pos = 0) const; size_t find (const char* s, size_t pos = 0) const; find_first_of(const string& str); // 子字符串和字符串共同具有的字符在字符串中首次出现的位置 2 栈 stack 没有迭代器功能。 #include #include stack s; stack > stk; //覆盖基础容器类型，使用vector实现stk s.empty(); //判断stack是否为空，为空返回true，否则返回false s.size(); //返回stack中元素的个数 s.pop(); //删除栈顶元素，但不返回其值 s.top(); //返回栈顶元素的值，但不删除此元素 s.push(item); //在栈顶压入新元素item 3 队列 queue 没有迭代器功能。 queue q; //priority_queue q; q.empty(); //判断队列是否为空 q.size(); //返回队列长度 // 出队和入队 q.push(item); //对于queue，在队尾压入一个新元素 q.pop(); //删除 queue 中的第一个元素 // 队列访问 q.front(); //返回队首元素的值，但不删除该元素 q.back(); //返回队尾元素的值，但不删除该元素 4 vector #include // 创建 vector vec; vector vec(int nSize); // 指定容器初始大小 vector(int nSize,const T& initValue):// 指定容器初始值 // 增加 vec.push_back(const T& item); // 在屁股添加 iterator vec.insert(iterator it,const T& item); // 迭代器指定位置插入元素 // 删除 vec.pop_back(); // 删除屁股 iterator erase(iterator it); // 删除迭代器指定位置元素 vec.clear(); // 删除全部 // 查找 vec[i]; vec.at(i); // 会检查是否越界，提高稳定性 // 容器内储存元素个数 vec.size(); // 容器是否有东西 vec.empty(); // 迭代器位置 vector::iterator it = vec.begin(); // 起始位置 vector::iterator it = vec.end(); // 结束位置 int a = *it; //获取值 *it += 1; // 定义二维数组 vector > obj(row); // row定义行数 排序： > : 从大到小排序 : 从小到大排序，默认方式 class Compare{ public: // 对象最好用引用进行传递 bool operator()(T const & a,T const & b){ return a > b; } }; // 调用函数 sort(vec.begin(),vec.end(),Compare()); 5 map/multimap map支持[ ]运算符，multimap不支持[ ]运算符。在用法上没什么区别。 key 不允许修改 //头文件 #include // 创建 map map; // 使用{}赋值是从c++11开始的，因此编译器版本过低时会报错，如visual studio 2012 map map = { { 2015, \"Jim\" }, { 2016, \"Tom\" }, { 2017, \"Bob\" } }; map map; // 指定排序规则 // 迭代器 map::iterator it = map.begin(); map::iterator it = map.end(); it->first; // key it->second; // 值 // 添加key value pair state;// 能判断是否插入成功;插入key存在时，返回false state = map.insert(pair(1, \"student_one\")); state = map.insert(map::value_type (1, \"student_one\")); map[key] = value; // key存在就覆盖，key没有就创建 // 查找 // 关键字查询，找到则返回指向该关键字的迭代器，否则返回指向end的迭代器 // 根据map的类型，返回的迭代器为 iterator 或者 const_iterator iterator find (const key_type& k); const_iterator find (const key_type& k) const; // 删除 // 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器 iterator erase( iterator pos ); // 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1 size_t erase( const key_type& key ); // 删除一定范围内的元素，并返回一个指向下一元素的迭代器 iterator erase( const_iterator first, const_iterator last ); // 清空map，清空后的size为0 void clear(); // 查询map是否为空 bool empty(); // 查询map中键值对的数量 size_t size(); // 查询关键字为key的元素的个数，在map里结果非0即1 ，可用于检测key是否包含 size_t count( const Key& key ) const; 排序： > : 从大到小排序 : 从小到大排序，默认方式 map map 对 key 进行排序。 map 不允许对 key 进行修改，所以 operator()引用与函数必须为 const class Compare{ public: bool operator()(const string & a,const string & b) const { return a.c_str()[0] names; 6 set/multiset 搜索、移除和插入计算速度 O(log(n))。 set 通常以红黑树实现。 set不允许两个元素有相同值。 不能通过set的迭代器去修改set元素，原因是修改元素会破坏set组织。 : *it += 1 #include // 创建 set names; set names; // 指定排序规则 // 添加 pair::iterator, bool> ret = names.insert(name); // 删除 names.erease(name); names.clear(); // 查找，找不到返回 end() set::iterator it = names.find(name); // 迭代器 set::iterator it = names.begin(); set::iterator it = names.end(); *it; // 计数 names.count(name); names.size(); names.empty(); 排序： > : 从大到小排序 : 从小到大排序，默认方式 set 不允许对 key 进行修改，所以 operator()引用必须为 const class Compare{ public: bool operator()(const string & a,const string & b) const { return a.c_str()[0] names; 7 deque #include // 创建 deque que; // 首尾操作 que.push_back(item); que.pop_back(); que.push_front(); que.pop_back(); que.front(); que.back(); // 删除 que.erase(it); que.clear(); // 查找 没有查找 用 #include 库中的 find 8 二叉堆 完全二叉树 父节点的编号为k，子左节点编号为2k，子右节点的编号为2k+1 子节点的编号为x，父节点的编号为 ⌊x/2⌋\\lfloor x/2 \\rfloor⌊x/2⌋ 从上往下最后一个父节点的编号为 ⌊n/2⌋\\lfloor n/2 \\rfloor⌊n/2⌋ ,nnn 总节点数 数组存储 最大二叉堆： 每个节点 >= 子节点 最小二叉堆： 每个节点 9 并查集（union_find） 9.1. 概念 [!note|style:flat] 使用前提： 一堆独立的元素 问题与关于这些元素「能否动态连通」有关，即将问题转为「元素之间连没连通」。「连通」也可以理解为共性，等效。 并查集解题思路：想办法让元素「分门别类」，建立动态连通关系。 class UF { /* 将 p 和 q 连接 */ public void union(int p, int q); /* 判断 p 和 q 是否连通 */ public boolean connected(int p, int q); /* 返回图中有多少个连通分量 */ public int count(); /* 找根 */ public int findRoot(int q); } class UnionSet{ public: vector parents; vector weights; // 统计连通分量 int count; void initialize(int n){ for(int i = 0; i weights[rootB]) { parents[rootB] = rootA; weights[rootA] += weights[rootB]; }else{ parents[rootA] = rootB; weights[rootB] += weights[rootA]; } count--; } bool isConnect(int a,int b){ int rootA = findRoot(a); int rootB = findRoot(b); if (rootA == rootB) { return true; } return false; } }; [!note] 并查集：一个集合有多少元素毫不相关；一个集合中的两个元素是否连通。 连通分量：集合中毫不相关的元素有多少。比如上图为8。 连通： 自反：自己和自己连通 对称：两个元素互相连通 传递：a与b连通，b与c连通，则c与a之间也是连通的。 9.2 基本实现 1. 数据结构 利用一个数组parent[]来储存集合元素，来实现一个图存储： 1）数组的索引为元素值； 2）数组的值为元素的父节点。 元素的初始存储形式： 2. 合并 [!tip] 将两个元素遍历到根节点 将两个根节点连接起来 void merge(int a,int b){ // 找根 int rootA = findRoot(a); int rootB = findRoot(b); if(rootA == rootB){ return; } // 连接 parents[rootA] = rootB; count--; } 3. 连通 [!tip] 将两个元素遍历到各自的根 对比根是否一样？连通：不连通 // 是否连通 bool isConnect(int a,int b){ // 查根 int rootA = findRoot(a); int rootB = findRoot(b); if (rootA == rootB) { return true; } return false; } 9.3 平衡性优化 当合并两颗树时，将节点多的一颗树接到轻的树上时，就会造成树的生长不稳定，所以在接树的时候，需要对比两颗树的节点数，少数服从多数。 void connect(int a,int b){ // 找根 int rootA = findRoot(a); int rootB = findRoot(b); if(rootA == rootB){ return; } // 连接 if (weights[rootA] > weights[rootB]) { parents[rootB] = rootA; weights[rootA] += weights[rootB]; }else{ parents[rootA] = rootB; weights[rootB] += weights[rootA]; } count--; } 9.4 路径压缩（最重要） [!note|style:flat] element != parents[element]，节点与父节点不一样，就能跳过父节节点，直达爷节点。由于父节点自己指向自己，两个节点时，不会越界。 // 查找 int findRoot(int element){ while (element != parents[element]) { // 把当前节点的父节点跳一级，实现路径压缩 parents[element] = parents[parents[element]]; element = parents[element]; } return element; } [!tip|style:flat] 压缩路径的优化性能较强与平衡性优化，平衡性优化可以不用写。 9.5 判定合法算式 题目： 给一组[\"a==b\",\"b!=c\",\"c==a\"]的关系式，判断这些式子能否成立。 ==：当成两个元素连通 !=: 两个元素不通 "},"cpp/chapter/array_list.html":{"url":"cpp/chapter/array_list.html","title":"九、数组链表操作","keywords":"","body":" 数组链表操作 1 排序 1.1. 冒泡排序 稳定排序，排序之后，数据输入顺序不会乱掉 string str; for (int i = 0; i 1.2. 桶排序 桶排序可以实现稳定排序 int* in; // 构建一个桶 vector > bucket(amount,vector()); // 排序 for(int i=0; i 1.3. 快速排序 若要对nums[lo..hi] 进行排序，我们先找一个分界点 p，通过交换元素使得 nums[lo..p-1] 都小于等于 nums[p]，且 nums[p+1..hi] 都大于 nums[p]，然后递归地去 nums[lo..p-1] 和 nums[p+1..hi] 中寻找新的分界点，最后整个数组就被排序了。 2 链表 2.1. 构建链表 在头部叠加 void appendNode(int val){ Node* newNode = new Node(val); if (this->head == NULL) { this->last = newNode; this->head = newNode; }else{ // 在头部叠加 newNode->next = this->head; this->head = newNode; } size++; } 在尾部增加 void pushNode(int val){ Node *newNode = new Node(val); if (this->head == NULL) { this->head = newNode; this->last = newNode; }else{ // 在尾部添加 this->last->next = newNode; this->last = newNode; } size ++; } 2.2. 逆向 1. 整体逆向: 靠递归的返回过程，完成反转 ListNode reverse(ListNode head) { // 深入的终止调节 if (head.next == null) return head; // 返回的链表的尾节点是 head.next ListNode last = reverse(head.next); // 在尾节点增加一个节点 head.next.next = head; // 断开之前方向的链接 head.next = null; return last; } 2. 从首开始的n个局部逆向 将n+1节点位置储存，通过上面递归进行逆向，最后把 n+1 节点接回去。 ListNode successor = null; // 记录第 n + 1 个节点 // 反转以 head 为起点的 n 个节点，返回新的头结点 ListNode reverseN(ListNode head, int n) { if (n == 1) { // 记录第 n + 1 个节点 successor = head.next; return head; } // 以 head.next 为起点，需要反转前 n - 1 个节点 ListNode last = reverseN(head.next, n - 1); head.next.next = head; // 让反转之后的尾节点 head 和后面的节点连起来 head.next = successor; return last; } 3. 对m到n的节点进行逆向: 找到对m-1节点进行记录，然后用上面方法逆向，然后接回去。 // 找到第m个节点，然后返回这个节点 ListNode reverseBetween(ListNode head, int m, int n) { // base case if (m == 1) { return reverseN(head, n); } // 前进到反转的起点触发 base case，n也用减 1 ，一会儿反转是按照总长度来的 head.next = reverseBetween(head.next, m - 1, n - 1); return head; } 1.3. 一块一块逆向 循环实现: 将当前节点，用头方向增长的方式，重新生成一个链表 void reverse(Node* head){ Node* inverseHead = NULL; Node* currentNode = head; Node* temp = NULL; this->last = currentNode; while ( currentNode != NULL) { // 由于还要用，临时存一下 temp = currentNode->next; // 将当前的节点组成新的链表，采用头部增长的方式 currentNode->next = inverseHead; inverseHead = currentNode; // 更新 currentNode = temp; } this->head = inverseHead; } 块逆向: 递归深入拆分块，回退拼接块 reverse(a, b): 翻转的区间为：[a,b) ListNode reverseKGroup(ListNode head, int k) { if (head == null) return null; // 区间 [a, b) 包含 k 个待反转元素 ListNode a, b; a = b = head; // 循环完毕后，b已经到了 a+k ，[a，b]中间间隔了 k+1 个节点了 for (int i = 0; i 3 回文 5.1. 字符遍历找回文 string palindrome(string& s, int l, int r) { // 防止索引越界 while (l >= 0 && r 5.2. 判断链表是否是回文 最简单的办法就是，把原始链表反转存入一条新的链表，然后比较这两条链表是否相同。 // 左侧指针 ListNode left; boolean isPalindrome(ListNode head) { left = head; return traverse(head); } boolean traverse(ListNode right) { if (right == null) return true; boolean res = traverse(right.next); // 后序遍历代码 res = res && (right.val == left.val); left = left.next; return res; } 4 双指针 4.1. 快慢指针 快慢指针一般都初始化指向链表的头结点head，前进时快指针fast在前，慢指针slow在后。 1. 判定链表中是否含有环 `fast`的移动速度为`slow`的两倍。 boolean hasCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) return true; } return false; } 2. 已知链表中含有环，返回这个环的起始位置 ListNode detectCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) break; } // 上面的代码类似 hasCycle 函数 slow = head; while (slow != fast) { fast = fast.next; slow = slow.next; } return slow; } fast一定比slow多走了k步，这多走的k步其实就是fast指针在环里转圈圈，所以k的值就是环长度的「整数倍」。 3. 链表的中间位置 ListNode middleNode(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; } // slow 就在中间位置 return slow; } 链表的长度是奇数，slow恰巧停在中点位置 链表的长度是偶数，slow最终的位置是中间偏右： 4. 寻找链表的倒数第n个元素 让快指针先走n步，然后快慢指针开始同速前进;这样当快指针走到链表末尾null时，慢指针所在的位置就是倒数第n个链表节点（n不会超过链表长度） ListNode removeNthFromEnd(ListNode head, int n) { ListNode fast, slow; fast = slow = head; // 快指针先前进 n 步 while (n-- > 0) { fast = fast.next; } if (fast == null) { // 如果此时快指针走到头了， // 说明倒数第 n 个节点就是第一个节点 return head.next; } // 让慢指针和快指针同步向前 while (fast != null && fast.next != null) { fast = fast.next; slow = slow.next; } // slow.next 就是倒数第 n 个节点，删除它 slow.next = slow.next.next; return head; 5. 有序数组/链表去重 数组nums[]有顺序，slow走在后面，快指针fast走在前面探路，比较nums[fast]与nums[slow]，找到不重复的元素就告诉slow并让slow前进一步。nums[0 slow]便是去重后的数组。 int removeDuplicates(int[] nums) { if (nums.length == 0) { return 0; } int slow = 0, fast = 0; while (fast ListNode deleteDuplicates(ListNode head) { if (head == null) return null; ListNode slow = head, fast = head; while (fast != null) { if (fast.val != slow.val) { // nums[slow] = nums[fast]; slow.next = fast; // slow++; slow = slow.next; } // fast++ fast = fast.next; } // 断开与后面重复元素的连接 slow.next = null; return head; } 注: 由于c++还需要对new的对象进行手动释放，所以可以用数组来储存链表节点，或者使用智能指针。 6. 删除目标元素，不改变数组顺序 不要求数组有序，如果fast遇到需要去除的元素，则直接跳过，否则就告诉slow指针，并让slow前进一步。nums[0 slow-1]是去除元素后的数组 int removeElement(int[] nums, int val) { int fast = 0, slow = 0; while (fast 7. 移动零 上一问题的变种 4.2. 左右指针 一般初始化为: left = 0, right = nums.length - 1 二分查找 翻转数组 双指针，升序列，求两数之和 1. 田忌赛马 struct Entry{ int index; int val; Entry(int index, int val) : index(index), val(val){ } Entry(){} }; class Compare{ public: bool operator()(const Entry & A,const Entry & B)const{ if (A.val > B.val) { return true; } return false; } }; void optinalSequence(const int* nums1,int* nums2,int n ){ vector target; vector option; for (int i = 0; i target[i].val) { nums2[target[i].index] = option[right]; right--; }else{ // 打不赢，就用小的凑数 nums2[target[i].index] = option[left]; left++; } } } 凌乱的数组先排序 left: 指向最小的一端 right: 指向最大的一段 "},"cpp/chapter/find.html":{"url":"cpp/chapter/find.html","title":"十、目标查找","keywords":"","body":" 查找问题 1 二分法 1.1. 基本的二分搜索 while(left 一次搜索的区间是：[left, right] while(left 终止条件：left == right + 1: 就两种情况会终止，1）right减过头；2）left加过头 int binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 注意 while(left target) right = mid - 1; // 注意 } return -1; } [!note|style:flat] 注： nums = [1,2,2,2,3];targe = 2;找目标的边界，普通二分法无法实现。 1.2. 寻找左侧边界的二分搜索 while(left 一次搜索的区间是：[left, right] while(left 终止条件：left == right + 1: 就两种情况会终止，1）right减过头；2）left加过头 left = [0,nums.length] 返回值含义：nums中小于target的值的个数 nums循序排列，target在数组nums中。 int left_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left target) { right = mid - 1; } else if (nums[mid] == target) { // 别返回，锁定左侧边界 right = mid - 1; } } // 最后要检查 left 越界的情况，target值也不在数组中 if (left >= nums.length || nums[left] != target) return -1; return left; } 1.3. 寻找右侧边界的二分搜索 返回值含义：nums中大于target的值的个数 nums循序排列，target在数组nums中。 int right_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left target) { right = mid - 1; } else if (nums[mid] == target) { // 别返回，锁定右侧边界 left = mid + 1; } } // 最后要检查 right 越界的情况 if (right 注： while(left 结束条件为 left == right while(left 一次搜索的区间是：[left, right) while(left 决定了left = mid + 1;right = mid;下一次的搜索区间就是：[left,mid) [left, right)就确定了初始条件：left = 0, right = nums.length int right_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0, right = nums.length; while (left target) { right = mid; } } if(left == 0 || nums[left - 1] != target){ return -1; } return left - 1; // 注意 } 2 two sum 2.1. 问题 给一个数组和一个整数target，可以保证数组中存在两个数的和为target，返回这两个数的索引。 例: 输入: nums = [3,1,3,6],target = 6 返回数组: [0,2] 1.2. 双指针暴力枚举 void twoSum(int* nums,int target,int * out){ for(int i=0;i 1.3. 哈西表查询第二个值 void twoSumMap(int*nums,int n,int target,int* out){ // 存储 值-索引 map valIndex; for (int i = 0; i 0 && valIndex[other] != i) { out[0]=i; out[1]=valIndex[other]; return; } } } 1.4. 双指针，升序列，求两数之和 int[] twoSum(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left target) { right--; // 让 sum 小一点 } } return new int[]{-1, -1}; } 1.5. 输出所有不重复的组合 void twoSum(vector &nums,int target){ // 先排序 sort(nums.begin(),nums.end()); int left = 0; int right = nums.size() - 1; int temp; while(left target){ right --; }else if(sum == target){ cout 1.6. 3Sum 问题 sort(): 首先进行排序 从左向右依次遍历数组 nums[index] target =target - nums[index]: 将3sum问题转为2sum问题。 nums[index]还要去重复 vector > twoSum(vector &nums,int start,int target){ vector > out; int left = start; int right = nums.size() - 1; int temp; while(left target){ right --; }else if(sum == target){ out.push_back(vector()); out[out.size() - 1].push_back(nums[left]); out[out.size() - 1].push_back(nums[right]); // 左边重复 temp = nums[left]; while(left > threeSum(vector &nums,int target){ // 先排序 sort(nums.begin(),nums.end()); vector > out; int index = 0; int temp; while (index > res = twoSum(nums,index+1, target - nums[index]); // 去重复 temp = nums[index]; while (index & item : res){ item.push_back(temp); out.push_back(item); } } return out; } 3 删除/查找数据O(1) 使用map存储索引，vector存储数据 查找: 通过map找索引，通过索引去vector拿数据 删除: 将最后一个元素与删除元素进行替换，修改map，然后再删除索引和数据 4 区间问题 4.1. 解题技巧 端点排序：按照区间起点排序，或者先按照起点升序排序，若起点相同，则按照终点降序排序。 不降序，会出问题 作图：分别讨论一次涉及的循环区间，有哪些情况，防止漏掉。 区间关系条件得找对。 4.2. 区间覆盖问题 int removeCoveredIntervals(int[][] intvs) { // 按照起点升序排列，起点相同时降序排列 Arrays.sort(intvs, (a, b) -> { if (a[0] == b[0]) { return b[1] - a[1]; } return a[0] - b[0]; }); // 大区间 int left = intvs[0][0]; int right = intvs[0][1]; int res = 0; for (int i = 1; i = intv[1]) { res++; } // 情况二，找到相交区间 if (right >= intv[0] && right 4.3. 区间合并 struct Interval{ int left; int right; Interval(){} Interval(int left, int right){ this->left = left; this->right = right; } }; class Compare{ public: bool operator()(const Interval & a, const Interval & b)const{ if (a.left b.right) { return true; } } return false; } }; vector mergeIntervals(vector& intervals){ // 排序 sort(intervals.begin(), intervals.end(),Compare()); vector res; int left = intervals[0].left; int right = intervals[0].right; res.push_back(Interval(left, right)); for (int i = 1; i = left && curR = left && curL right){ // 相交 res.back().right = curR; right = curR; }else if(curL > right){ // 分离 left = curL; right = curR; res.push_back(Interval(left, right)); } } return res; } 4.4. 区间交集 归纳交集：!(l1 > r2 || r1 归纳指针移动条件：(r1 vector intersection(vector& inter1, vector& inter2){ // 先排序 sort(inter1.begin(), inter1.end(),Compare()); sort(inter2.begin(), inter2.end(),Compare()); // 区间指针 int index1=0,index2=0; int left,right; vector res; // 遍历区间 while (index1 r2 || r1 4.5. 给定两矩形，求相交面积 排序：矩形可以由两个点对角点表示，首先需要确定两个的位置 作图：判断相交关系 // 确保起点在下，终点在上 Rect getRect(int x1,int y1,int x2,int y2){ Rect A; A.xStart = min(x1,x2); A.yStart = min(y1,y2); A.xEnd = max(x1,x2); A.yEnd = max(y1,y2); return A; } int intersectionRect(Rect A,Rect B){ // 判断是否相交 if(!(A.xStart >= B.xEnd || A.xEnd = B.yEnd)){ Rect intersection; intersection.xStart = max(A.xStart,B.xStart); intersection.yStart = max(A.yStart,B.yStart); intersection.xEnd = min(A.xEnd,B.xEnd); intersection.yEnd = min(A.yEnd,B.yEnd); return (intersection.xEnd - intersection.xStart) * (intersection.yEnd - intersection.yStart); } return 0; } 5 二分法威力加强 [!tip] 0. 求解该问题可以对一个单调函数区间暴力遍历 1. 解为一个单调函数里的某一值。 2. 单调函数可以根据一个状态，将区间划分为两半。 二分法找值： 单调：数组需要先排序 状态：和mid比大小 区间：mid的「左边」或者「右边」 5.1 珂珂吃香蕉 calculateH(speed)单调函数，随speed增加而减小 (calculateH(nums,n,mid) 将speed区间划分为两半 int calculateH(const int* nums,int n, int speed){ int h = 0; for(int i = 0; i 0 ? 1 : 0); } return h; } int minSpeed(const int* nums,int n,int H){ // 最大的情况 int right = findMax(nums,n); int left = 1; while(left H){ left = mid + 1; } } return left; } 5.2 运输货物 void findBorder(const vector& goods,int & left,int & right){ for(int item:goods){ left = max(left,item); right += item; } } int calculateDay(const vector& goods,int w){ int count = 0; int day = 0; for(int item:goods){ count += item; // 超重 if (count > w) { // 重置，并回退一个货物 count = item; day ++; } } // 没装完 if (count != 0) { day ++; } return day; } int minWeight(const vector& goods,int day){ int left = 0; int right = 0; // 寻找区间 findBorder(goods,left,right); while(left day){ left = mid + 1; } } return left; } 5.3 分割数组的最大值 问题5.2的变种。 6 滑动窗口 [!note|style:flat] 滑动窗口主要用于解决，在长序列上，不要求顺序，找子序列的各种问题，。 6.1 模板 [!tip] 可以想象成一条虫子在一根线上从左向右蠕动。 先头动，搜寻问题的解，更新状态 后尾动，优化找到的解，更新状态。 int left = 0, right = 0; while (right /* 滑动窗口算法框架 */ void slidingWindow(string s, string t) { // 标记序列用 // window：标记主序列；need：标记子序列 unordered_map need, window; for (char c : t) need[c]++; // 窗的左右边界 int left = 0, right = 0; // 有效信息的标记值 int valid = 0; while (right [!warning|style:flat] window[]在扩展窗口时，最先更新。 window[]在收缩窗口时，最后更新。 6.2 最小覆盖子串 string coveredSubsequences(const string &s,const string &t){ unordered_map windows; unordered_map need; // 标记字串 for(char ch : t){ need[ch]++; } int len = s.size() + 1; int start = len; int left = 0; int right = 0; int valid = 0; // 头挪动 while (right right - left){ len = right - left; start = left; } // 出去一个 char outch = s[left]; left++; if (need.count(outch) && windows[outch] == need[outch]) { valid--; } // 操作完毕再取消 windows[outch]--; } } if (len == s.size() + 1) { return \"\"; } return s.substr(start,len); } 6.3 字符串排列 while (right = B.length()) { // 字符都找到了 if (valid == need.size()) { return true; } 。。。 } right - left >= B.length():使用>=，不满足条件时，还要缩小窗口。 bool substring(const string & S,const string & B){ unordered_map window,need; for(char ch:B){ need[ch]++; } int left = 0; int right = 0; int valid = 0; while (right 0) { window[ch]++; // 满足要求 if (window[ch] == need[ch]) { valid += 1; } } // 找到解的评判标准是：字符串长度 while (right - left >= B.length()) { if (valid == need.size()) { return true; } char ch = S[left]; left++; if (need.count(ch)) { if(window[ch] == need[ch]){ valid--; } window[ch]--; } } } return false; } 6.4 找所有字母异位词 解题思路和6.3一样。 vector diffSubstring(const string& s1, const string& s2){ // 存储索引 vector starts; unordered_map need,window; for(char ch:s2){ need[ch]++; } int left=0; int right=0; int valid = 0; while(right = s2.length()) { if (valid == need.size()) { starts.push_back(left); } char ch = s1[left]; left++; if (need.count(ch)) { if (need[ch] == window[ch]) { valid--; } window[ch]--; } } } return starts; } 6.5 最长无重复子串 int findMaxLen(const string& str){ unordered_map window; int left=0; int right=0; int maxLen = 0; while(right 1) { char out = str[left]; left++; window[out]--; } maxLen = max(maxLen,right - left); } return maxLen; } "},"cpp/chapter/binaryTree.html":{"url":"cpp/chapter/binaryTree.html","title":"十一、二叉树","keywords":"","body":" 二叉树 1. 递归的逻辑 明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节。 以内部函数调用为分界，上部分是入栈，下部分是出栈 // 定义：count(root) 返回以 root 为根的树有多少节点 int count(TreeNode root) { // base case if (root == null) return 0; // 自己加上子树的节点数就是整棵树的节点数 return 1 + count(root.left) + count(root.right); } 2. 二叉树的操作逻辑 先搞清楚当前 root 节点「该做什么」(重点)以及「什么时候做」(前，中，后)，然后根据函数定义递归调用子节点。 /* 二叉树遍历框架 */ void traverse(TreeNode root) { // 前序遍历 traverse(root.left) // 中序遍历 traverse(root.right) // 后序遍历 } 3. 二叉树前，中，后序列化与反序列化 序列化储存形式：12#4 3,#表示空节点 改变「解析」和「序列化」位置，可以分别实现前，中，后。 深度优先搜索 struct Node{ int value; Node* left; Node* right; Node(){ left = nullptr; right = nullptr; } ~Node(){ if (left != nullptr) { delete left; } if (right != nullptr) { delete right; } } }; class BinaryTree{ private: const string nullStr = \"#\"; public: Node* deserialize(queue &nodes){ // 读取一个节点 string str = nodes.front(); nodes.pop(); // 到头了 if (str == nullStr) { return nullptr; } // 解析 Node* node = new Node(); node->value = stoi(str); // 解析左右节点 node->left = deserialize(nodes); node->right = deserialize(nodes); return node; } string serialize(Node* root){ // 节点到头了 if (root == nullptr) { return nullStr; } // 序列化 string str = to_string(root->value); // 序列化左右 str = str + serialize(root->left); str = str + serialize(root->right); return str; } }; 4. 二叉树层级遍历的序列化与反序列化 序列化: 递归的作用，1）将父节点输出；2)子节点入队；3）当父节点出队 string serializeProcess(Node* root){ if (nodeQueue.empty()) { return \"\"; } // 搜索到头 string str = \"\"; if (root == nullptr) { str = nullnode; }else{ str = to_string(root->value); // 子节点入队 nodeQueue.push(root->left); nodeQueue.push(root->right); } // 将当前节点弹出 nodeQueue.pop(); str = str + serializeProcess(nodeQueue.front()); return str; } string serialize(Node* root){ while (!nodeQueue.empty()) { nodeQueue.pop(); } // 初始化队列 nodeQueue.push(root); return serializeProcess(nodeQueue.front()); } 反序列化： 递归的作用，1）父节点出队；2）解析左右子节点；3）子节点入队 void deserializeProcess(queue& nodes){ if(nodes.empty()){ return; } // 取出一个父类 Node* parent = nodeQueue.front(); nodeQueue.pop(); string str = \"\"; Node* node = nullptr; // 取出左子节点 str = nodes.front(); nodes.pop(); if (str == nullnode) { node = nullptr; }else{ node = new Node(); node->value = stoi(str); nodeQueue.push(node); } parent->left = node; // 取出右子节点 str = nodes.front(); nodes.pop(); if (str == nullnode) { node = nullptr; }else{ node = new Node(); node->value = stoi(str); nodeQueue.push(node); } parent->right = node; deserializeProcess(nodes); } Node* deserialize(queue& nodes){ while (!nodeQueue.empty()) { nodeQueue.pop(); } if (nodes.front() == nullnode) { return nullptr; } Node* root = new Node(); root->value = stoi(nodes.front()); nodes.pop(); nodeQueue.push(root); deserializeProcess(nodes); return root; } 5. 翻转二叉树 void invertTree(Node * root){ if (root == nullptr) { return; } // 交换节点 Node* temp = root->left; root->left = root->right; root->right = temp; invertTree(root->left); invertTree(root->right); } 6. 连通完全二叉树一层的节点 // 主函数 Node connect(Node root) { if (root == null) return null; connectTwoNode(root.left, root.right); return root; } // 辅助函数 void connectTwoNode(Node node1, Node node2) { if (node1 == null || node2 == null) { return; } /**** 前序遍历位置 ****/ // 将传入的两个节点连接 node1.next = node2; // 连接相同父节点的两个子节点 connectTwoNode(node1.left, node1.right); connectTwoNode(node2.left, node2.right); // 连接跨越父节点的两个子节点 connectTwoNode(node1.right, node2.left); } [!tip|style:flat] 「将每两个相邻节点都连接起来」 7. 将二叉树变链表 将 root 的左子树和右子树拉平 将 root 的右子树接到左子树下方 将整个左子树作为右子树。 // 定义：将以 root 为根的树拉平为链表 void flatten(TreeNode root) { // base case if (root == null) return; flatten(root.left); flatten(root.right); /**** 后序遍历位置 ****/ // 1、左右子树已经被拉平成一条链表 TreeNode left = root.left; TreeNode right = root.right; // 2、将左子树作为右子树 root.left = null; root.right = left; // 3、将原先的右子树接到当前右子树的末端 TreeNode p = root; while (p.right != null) { p = p.right; } p.right = right; } 8. 构造最大二叉树 左右拆分找节点 Node* constructMaximumBinaryTree(int* nums,int left,int right){ if(left > right){ return nullptr; } // 找最大值 int max = nums[left]; int maxIndex = left; for (int i = left + 1; i value = max; node->left = constructMaximumBinaryTree(nums,left,maxIndex - 1); node->right = constructMaximumBinaryTree(nums,maxIndex + 1,right); return node; } 9. 通过「前序和中序」遍历结果构造二叉树 递归创建处理root节点 在中序中，找root节点位置 左右拆分，进行递归。 重点为preorder,inorder如何拆两半 。 两种序列，传参时，不能搞错了。 Node* fromPreIn(int* preorder,int preL,int preR,int* inorder,int inL,int inR){ if (preL > preR || inL > inR) { return nullptr; } // 根节点 Node* root = new Node(); root->value = preorder[preL]; // 中序中，找root所在位置 int index = 0; for ( index = inL; index value){ break; } } // 两个子节点 root->left = fromPreIn(preorder,preL + 1,preL + (index - inL), inorder,inL,index - 1); root->right = fromPreIn(preorder,preL + (index - inL) + 1,preR, inorder,index + 1,inR); return root; } 10. 通过「中序和后序」遍历结果构造二叉树 [!note|style:flat] 注意： postR - 1 root->left = fromPostIn(postorder,postL,postL + interval - 1, inorder,inL,index - 1); root->right = fromPostIn(postorder,postL+interval,postR - 1, inorder,index+1,inR); "},"cpp/chapter/dynamicProgram.html":{"url":"cpp/chapter/dynamicProgram.html","title":"十二、动态规划","keywords":"","body":" 动态规划 1 动态规划概念 动态规划问题的一般形式就是求最值。 重叠子问题: 最终点问题是由某一单步小问题的重复，这些 小问题的求解可能会重复计算。 最优子结构: 当前步骤的最优只与\"上一步\"有关。根据这个特点可以状态压缩 状态转移方程: 递推式，解决问题的核心。 1.1. 解题框架 明确 base case: 如何初始化dp[]；确定边界条件。 明确「状态」: 推进子问题向大问题演变的变量。就是dp[i]的游标i的含义。 明确「选择」: 可以使得由过去的状态i-1,i-2,i-3...向当前状态i推进的 「选择」。 定义 dp 数组/函数: dp值 = f（当前状态） dp函数: 参数就是上面说到的「状态」。函数的返回值就是「结果」。 dp[i] 数组：i为「状态」，「结果」为dp[i] # 初始化 dp[] = init # 边界条件 dp[0][0][...] = base # 进行状态转移 for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 求最值(选择1，选择2...) 1.2. 流程方向 自顶向下: 从目标开始，把大问题拆解小问题，直到到初始条件。 暴力递归: 把大问题拆成小的，递归下去 备忘录递归: 算过的值记录下来，不在重复算 自底向上: 从初始开始，根据递推式，一步一步迭代，直到目标结束。 dp数组: 从初始状态，根据递推关系，算到目标状态，循环数组，不用递归。 1.3. 重复子问题的确定 dp[i][j] = min{ dp[i-1][j] + 1, dp[i][i-1] + 1, dp[i-1][j-1] + 1 }   当从dp[i-1][j-1]过度到dp[i][j]的求解有多种路径时，就存在解重叠的情况。采用备忘录和dp数组解决。 1.4. 状态遍历顺序 [!note|style:flat] 确定二维表dp[][]初始值 确定递推式dp[i][j]的依赖情况（上图左边） 根据依赖关系填充二维表，满足横向填充或者纵向填充 // i = 0, j = 0 的情况是边界条件，已经初始化好了。 for (int i = 1; i 2. 斐波那契级数 题目： 某人有一对兔子饲养在围果它们每个月生1对兔子，且新的兔子在第2个月后(3个月为周期)也是每个月生1对兔子,问一年后围墙中共有多少对兔子。 递推式： f(n)=f(n−1)+f(n−2)\r f(n) = f(n-1) + f(n - 2)\r f(n)=f(n−1)+f(n−2) 序列为：1，1，3，5，8，13，21，34，55，89。。。 3. 凑零钱问题 题目： 给你k种面值的硬币，面值分别为c1, c2 ... ck，每种硬币的数量无限，再给一个总金额amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1。 分析： [!tip] 状态： amount 能推荐问题递推，问题的结果由amount影响 选择： 每次「状态」的推进，由c1, c2 ... ck确定。 dp[amount]定义：dp[amount]表示，当总金额为amount时，最少硬币数为dp[aomunt] int coinChange(const int * coins,int n,int amount){ // 定义dp[i]: 状态为钱总数；结果为当前总价最少钱币数 // 初始化放入极端值,由于是求解最小，所以放入一个大值 vector dp(amount + 1,amount + 1); // 边界条件 dp[0] = 0; for(int i=2;i = coins[j]){ dp[i] = min(dp[i],dp[i - coins[j]] + 1); } } } // 找不到 if (dp[amount] == amount + 1) { return -1; } return dp[amount]; } 2. 子序列问题 2.1. 最长递增(递减)子序列 问题特征： [!note|style:flat] 首先给一组1维的长序列， 若是2维问题，看看能不能排序降为1维问题。 要求子序列具有「某种单调关系」 目标子序列是关系下的「最长子序列」 分析： [!tip] 状态： 当前查找的序列的以索引i结束 选择： 选择dp[i-1],dp[i-2]...确定dp[i]。 dp[i]定义： 以索引i结束的序列，最长子序列的长度dp[i] int lengthOfLIS(vector& seq){ vector dp(seq.size(),1); dp[0] = 1; // 状态从 1 索引开始 for(int i=1;i seq[j]){ dp[i] = max(dp[i],dp[j] + 1); } } } int max = 1; for(int item:dp){ if(item > max) max = item; } return max; } 2.2 信封嵌套问题 1. 降维 [!note|style:flat] 嵌套问题是要求[w,h]「两个」数据均有「单调的大小」关系，属于2维问题。而递增子序列问题是1维问题。 将「2维问题」转「1维问题」可以使用「排序」，先确定一个维度的关系，然后就只用关心一个维度。 排序：对于[v1,v2]形式，一般优先v1升序，若v1相等，则v2降序 2. 问题求解 [!tip] 排序 : 保证对1维序列进行操作，两点（[v1，v2]）数据，先排序：v1升序，v2降序 状态： 当前查找的序列的以索引i结束 选择： 选择dp[i-1],dp[i-2]...确定dp[i]。 dp[i]定义： 以索引i结束的序列，最长子序列的长度dp[i] struct Envelope { int width; int height; bool greatThan(const Envelope& temp){ if (this->width > temp.width && this->height > temp.height) { return true; } return false; } }; int maxEnvelopeLen(vector &envelopes){ // width 升序，hight 降序 sort(envelopes.begin(), envelopes.end(),[](const Envelope & A, const Envelope & B)->bool{ if (A.width B.height){ return true; } } return false; }); vector dp(envelopes.size(),1); for(int i=0;i 2.3 最小编辑距离 [!tip] 状态： 解决两个字符串的动态规划问题，一般都是用「两个指针」，即「两个状态」。 当前考虑当两个字符串的索引在i,j时的情况。 选择： 删除，插入，替换，跳过 dp[i][j]定义： "},"cpp/chapter/monotoneStack.html":{"url":"cpp/chapter/monotoneStack.html","title":"十三、单调栈","keywords":"","body":" 单调栈 1 单调栈作用 根据当前入栈的值，栈内部会维持顺序（递增或递减）。 while (!s.empty() && s.top() : 比nums[i]小的都滚了，现在nums[i]最小，所以s是递减的 while (!s.empty() && s.top() >= nums[i]): 比nums[i]大的都滚了，现在nums[i]最大，所以s是递增的 void monotonousStack(int* nums,int n){ stack s; // 值入栈 for (int i = n-1; i >= 0; i--){ // 确保当前值在栈中是最小的 while (!s.empty() && s.top() 2. Next Greater Number 主要解决问题 Next Greater Number: 在当前数组中，比当前数更大的下一个数 for 循环: 要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。 while循环: 是把两个“高个”元素之间的元素排除 void nextGreater(int* nums,int n,int* out){ stack s; for (int i = n-1; i >= 0; i--){ while (!s.empty() && s.top() 3. 「循环」的Next Greater Number 将数组扩展一倍，然后用单调栈 4. 与 Next Greater Number之间的距离 void nextGreaterInterval(int* nums,int n,int* out){ // 栈中存放索引 stack s; for (int i = n-1; i >= 0; i--){ while (!s.empty() && nums[s.top()] >= nums[i]) { // 栈顶的值小于等于当前值，索引滚蛋 s.pop(); } // 栈空的：没找到；不为空：栈顶就是 if (s.empty()) { out[i] = -1; }else{ out[i] = s.top() - i; } // 当前的 i 入栈 s.push(i); } } 5. 无序数组，去除重复值 要去重 重字符串中的字符顺序不能打乱s中字符出现的相对顺序 在所有符合上一条要求的去重字符串中，字典序最小的作为最终结果 字典序：指从前到后比较两个字符串大小的方法。首先比较第1个字符，如果不同则第1个字符较小的字符串更小，一直这样子比较下去。 void rmDuplicate(const string & str){ // 字符计数 map count; // 储存最终序列，以当前字符，内部是单增的 stack s; // 是否重复 map inStack; // 计数 pair::iterator,bool> res; for(char ch:str){ res = count.insert(pair(ch,1)); if (res.second == false) { count[ch] += 1; } } for(char ch:str){ // 取出一个 count[ch] --; // 栈里面有，去重复 if (inStack.count(ch) && inStack[ch] == true) { continue; } // 最小字典序：s是单调增加的 while (!s.empty() && s.top() > ch) { // 后面已经没了，不能在弹出 if (count[s.top()] == 0) { break; } inStack[s.top()] = false; s.pop(); } s.push(ch); inStack[ch] = true; } string out = \"\"; while (!s.empty()) { out += s.top(); s.pop(); } for(int i = out.length() - 1;i >=0;i--){ cout map count: 记录存在个数 map inStack: 用来去重复 stack s: 用于存放结果，并利用单调栈的特性，实现最小字典序 "},"cpp/chapter/toollib.html":{"url":"cpp/chapter/toollib.html","title":"附录 工具库","keywords":"","body":"工具库 1 math #include // 绝对值 int abs(int); double fabs(double); // 四舍五入 double round(double); // 取整 double ceil(double num); // 向上取整 double floor(double num);// 向下取整 // 余数 double fmod(double num，double base); %; 只能用于int; 2 regex \\b : 字符边界 . : 除 \\n 以外所有字符 \\w : 等价于 [(0-9)(a-z)(A-Z)(_)] ，数字，字母，下划线 \\W : 上面取反 [^(0-9)(a-z)(A-Z)(_)] \\d : 数字 \\D : 上面取反 \\s : 空白符(空格，制表符，换行) \\S : 上面取反 regex_search : 只返回第一次匹配到的子串 上面的匹配字符，编程用时还要再加一个 `\\` #include // 定义表达式 regex reg(\"[a-z0-9]+\"); // 是否匹配 bool regex_match(string,regex);//全匹配 bool regex_search(string,regex);//子串匹配，只匹配第一次找到的 // 捕获 bool reg_search(string，smatch，regex); smatch.size(); //匹配到的个数: 表达式匹配 + 捕获匹配 smatch.str(0); // 整个正则匹配到的部分 smatch.str(i); // 0之后的，都是捕获部分 smatch.prefix().str(); // 未匹配的前部分 smatch.prefix().str();// 未匹配的后部分 3 匿名函数 [!note] 只有c++11以上的编译器才支持。 [capture](Parameters)->return_type{ body; } capture: [] //未定义变量.试图在Lambda内使用任何外部变量都是错误的. [x, &y] //x 按值捕获, y 按引用捕获. [&] //用到的任何外部变量都隐式按引用捕获 [=] //用到的任何外部变量都隐式按值捕获 [&, x] //x显式地按值捕获. 其它变量按引用捕获 [=, &z] //z按引用捕获. 其它变量按值捕获 [!note|style:flat] [this](){this->;} 对于 this只能用值捕获。 parameters: 参数列表 return_type: 返回值 sort(vec.begin(),vec.end(),[](const Entry & A,const Entry & B) -> bool{ return A.val > B.val; }); "}}