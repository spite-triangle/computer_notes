{"./":{"url":"./","title":"简介","keywords":"","body":"简介 #btn{ background-color: #FF1D1D; margin-left: 20px; margin-right: 20px; -moz-border-radius: 12px; -webkit-border-radius: 12px; border-radius: 12px; -khtml-border-radius: 12px; vertical-align: middle; border: none; width: 35px; height: 35px; padding:1px; } .btn_bili{ background: url(\"image/button/bilibili.png\"); background-repeat: no-repeat; background-position: center center; background-size: 70% 70%; } .btn_github{ background: url(\"image/button/github.png\"); background-repeat: no-repeat; background-position: center center; background-size: 70% 70%; } .btn_book{ background: url(\"image/button/gitbook.png\"); background-repeat: no-repeat; background-position: center center; background-size: 80% 80%; } /* 鼠标悬停动画 */ #btn:hover{ width: 50px; height: 50px; background-color: #ff8080; transition-delay: 20ms; transition-duration: 100ms; transition-timing-function: ease-in-out; } .container{ background-color:#9F5C47; padding:20px; text-align:center; border-radius: 10px; margin-bottom: 5px; width:inherit; height:80px; /* 显示为盒子，为了居中 */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-pack: center; -webkit-box-align: center; display: -moz-box; -moz-box-orient: horizontal; -moz-box-pack: center; -moz-box-align: center; display: -o-box; -o-box-orient: horizontal; -o-box-pack: center; -o-box-align: center; display: -ms-box; -ms-box-orient: horizontal; -ms-box-pack: center; -ms-box-align: center; display: box; box-orient: horizontal; box-pack: center; box-align: center; } #btn_link{ /* 取消下划线 */ text-decoration: none; } 正在构建中。。。 "},"cpp/cpp.html":{"url":"cpp/cpp.html","title":"c/c++","keywords":"","body":"C++笔记 "},"cpp/chapter/foundation_withNum.html":{"url":"cpp/chapter/foundation_withNum.html","title":"一、基础概念","keywords":"","body":"基础知识 1. c语言文件 头文件后缀名： .h 源文件后缀名： .c 2. c++文件 头文件后缀名： .h, .hpp, .hxx 源文件后缀名：.cpp, .cc, .cxx, .C .c++ .hpp: 声明和实现都有 .inl: 内联函数 3. 内联函数   使用inline修饰的具体函数实现，非声明。编译期间对于编译器承认的inline函数，将会直接把代码拷贝到函数调用位置。 建议性质的关键字，只有简单的函数会被编译器承认。 默认地，类中定义的所有函数，除了虚函数之外，会隐式地或自动地当成内联函数; 虚函数也能用inline修饰，建议性质的。 泛型定义 4. 重定义    #include会将头文件复制，同一个东西头文件实现一次，源文件实现一次就会触发重定义。 5. main函数 int argc : 传入参数个数，默认为1 const char * argv[] : 输入的参数列表 一个字符串数组 argv[0] : 被执行程序（.exe文件）所在的绝对路径。 6. 编译器 gcc与g++进行文件编译时，会互相调用，但是编译.c文件除外；在链接时，不会互相调用。 预处理: -E，处理宏 编译:-S，生成汇编 汇编:-C，生成二进制 链接:-O，生成目标文件 7. 定义与声明 定义：表示创建变量或分配存储单元 定义必须有，且只能出现一次 声明：说明变量的性质，但并不分配存储单元;在 链接 时，查找具体定义。 声明可以出现多次 变量： // 声明 extern int i; // 声明了未定义，但是不能重复声明 class Test{ public: static int a; }; // 定义 int Test::a = 0; // 声明又定义 int i; int i = 1; extern int i = 1; // 函数外部才能被初始化 源文件中的全局变量 `int a;` 形式，默认修饰符为 `extern`。 函数: 带有{ }的就是定义，否则就是声明。 8. 模块化设计 模块即是一个.c文件和一个.h文件的结合，头文件(.h)中是对于该模块接口的声明，一般都用extern进行修饰； 供给其它模块调用的外部函数及全局变量需在.h中文件中冠以extern关键字声明； 模块内的函数和全局变量需在.c文件开头冠以static关键字声明； 永远不要在.h文件中定义全局变量！ 头文件中可以定义的实体，得有头文件保护，否则会重定义。 值在编译时就已知的 const 变量的定义可以放到头文件中 结构体，类的定义可以放到头文件中 inline 函数 9. 泛型 template: typename , class作用一样。 泛型的定义和实现必须在同一个文件中。 class Car{ public: // 类型别名 typedef float Speed; // 内部类 class Wheel{ }; static float price; }; float Car::price = 10; // 定义泛型 template class PrivateCar{ public: // 定义变量 typename T::Speed v; typename T::Wheel wheels; float getPrice(){ T::price = 100; // 变量 return T::price; } }; 10. 类型安全 类型安全:指同一段内存在不同的地方，会被强制要求使用相同的描述来解释(内存中的数据是用类型来解释的)，除非使用类型强制转换。 [!note|style:flat] c/c++ 并不是类型安全的语言。 int main() { // 使用浮点的形式输出整型，编译能够通过 printf(\"%f\\n\",10); // d的输出值很有可能不是 5 ，而是其他值，因为字节数错了。 int i=5; void* pInt=&i; double d=(*(double*)pInt); cout 11. 类型转换 11.1. c风格 11.1.1. 自动转换 将一种类型的数据赋值给另外一种类型的变量时就会发生自动类型转换 float f = 100; [!note] 100先转为一个「带有常性的临时变量100.0」 然后再将「带有常性的临时变量100.0」赋值给f 11.1.2. 混合数学运算 在不同类型的混合运算中: 将参与运算的所有数据先转换为同一种类型，然后再进行计算，最后结果在根据右端类型进行类型转化。 [!note|style:flat] 同一类型：转换按数据长度增加的方向转换同一 所有的浮点运算都是以double进行的，即使只有float char和 short 参与运算时，必须先转换成 int 类型。 运算结果值均是「带有常性的临时变量」（不管最后有没有类型转换） int a = 1.9 + 1.6 + 'a'; // 结果 100 float b= 10 / 3; // 结果为 3 如果除数和被除数都是整数，结果为整数; 如果有一个非整数，否则为小数 11.1.3. 强制转换 (类型)的优先级高于运算符 // 结果为 5.0 float b=(int)10.2 /0.2; 11.1.4. 类型转换只是临时性的 [!note|style:flat] 无论是自动类型转换还是强制类型转换，都是先将原来的值转化一个「临时的const类型值」，然后再进行赋值，并不会更改原来的数值。 11.2. c++类型转化 11.2.1. 原因 [!note] c风格的转换不容易查找 没有对转化进行分类，容易出问题。 11.2.2. 分类 类型转化 描述 static_cast 静态类型转换。 reinterpreter_cast 重新解释类型转换。 dynamic_cast 子类和父类之间的多态类型转换。 const_cast 去掉const属性转换 [!note|style:flat] 这些转换形式，都能通过c风格实现。 11.2.3. static_cast 静态类型转换 静态类型转换：在编译期内即可决定其类型的转换，就是一般变量间的转换。 float dpi; int num3 = static_cast (dPi); 11.2.4. dynamic_cast 用于多态中父子类之间的多态转换 [!tip] 转换成功，返回转换后类型； 转换失败，返回空值 只能用于type *与type &转换。 Animal* base = NULL; base = new Cat(); // 将⽗类指针转换成⼦子类， Dog *pDog = dynamic_cast(base); 11.2.5. const_cast [!note|style:flat] 去除const属性 只能用于type *与type &转换。 volatile const int a=1; int& b = const_cast(a); b = 2; cout (c); d = 2; cout [!note|style:flat] 得用volatile才能让a输出值改变，不然a到常量表取值。 a与b地址一样 11.2.6. reinterpret_cast 就是对内存进行重新规划，并不会改变内存里的二进制值。 int num = 0x00636261;//用16进制表示32位int，0x61是字符'a'的ASCII码 int * pnum = &num; char * pstr = reinterpret_cast(pnum); return 0; [!note] pstr与pnum指向地址值一样。 pstr按照1字节计算；pnum按照4字节计算。 "},"cpp/chapter/keyword_withNum.html":{"url":"cpp/chapter/keyword_withNum.html","title":"二、关键字","keywords":"","body":"关键字 1. new/delete 编译器分配内存的关键字，会调用构造器与析构器。malloc/free为库函数实现。 [!note|style:flat] new/delete与malloc/free分配内存后，均没用初始化。 // 分配内存，没有初始化 int* a = new int[10]; // 分配内存，初始化 0 int* a = new int[10](); // 通过传值初始化 int* a = new int[10](另一个int[10]的数组); delete[] a; // 申请一个值的空间 int* b = new int(5); delete b; // malloc 函数申请空间，没有初始化 int* a = (int *) malloc(sizeof(int)*10); free(a); 2. const // 限定内容 const int*p; int const *p; // 限定指针 int* const p; // 都限定 const int* const p; 2.1. c const变量: 可以通过指针修改值，就是一个建议。 2.2. c++ 类成员函数后: 这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。 const函数内，只能调用const函数。 类成员函数前: 返回值是一个常量，不能修改，通常用来限定引用。 const变量: 编译器会将常量优化，放到符号表，取值会从表中直接获取，而不是去内存。通过指针修改值后，值不变。 添加关键字volatile，可以防止编译器优化，从内存取值。通过指针修改值后，值会变。 const对象: 只能访问const与static修饰的内容。 3. override   配合 virtual 关键字使用；修饰子类 override 函数。 4. volatile 避免优化、强制内存读取的顺序。 没有线程同步的语义 5. static 函数体内： 修饰的局部变量作用范围为该函数体，在内存只被分配一次，下次调用的时候维持了上次的值。 源文件全局：修饰的全局变量或函数，范围限制在声明它的模块内，不能被extern找到。 类中修饰成员变量: 表示该变量属于整个类所有，对类的所有对象只有一份拷贝。 在类里声明，到类外实现 类外全局处实现，不用static修饰 全对象共享 类中修饰成员函数: 表示该函数属于整个类所有，不接受this指针，只能访问类中的static成员变量。 类的里/外都能实现，类外实现省略static 6. extern \"C\"   会指示编译器这部分代码按C语言的进行编译，而不是C++的;能够正确实现C++代码调用其他C语言代码。 7. extern   使用include将另一个文件全部包含进去可以引用另一个文件中的变量，但是这样做的结果就是，被包含的文件中的所有的变量和方法都可以被这个文件使用，这样就变得不安全。如果只是希望一个文件使用另一个文件中的某个变量还是使用extern关键字更好。 源文件中的全局变量与函数定义，默认都能被extern找到。 8. friend   可以让外部函数或者外部类，访问私有类的私有属性与函数。 友元函数 定义在类外的普通函数 需要在类中声明 友元类: 友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。 不能被继承 两个类的关系是单向的 不可传递 9. 储存类型符 auto：所有局部变量默认的存储类， 对于C， 块语句中也可定义局部变量，形参也是。 register: 存储在寄存器中（只是建议，具体实现看编译器）。 static：局部修饰变量后改变了生存期;全局变量修饰后改变了作用域 extern：引入其他.C文件中已定义的非static全局变量;可以在函数的内外声明变量或者函数。 mutable：仅适用于类的对象成员变量，它允许const函数能对成员变量进行修改 10. cin 10.1. 简介 遇到 \\n 才会将写入内容加载到缓冲区 \\n 也算一个字符，会被加载到缓冲区 缓冲区为空时，cin 阻塞等待数据;一旦缓冲区中有数据，就触发 cin 去读取数据。 遇到EOF会结束。 [!tip|style:flat] 可用来循环读取值 while(cin >> value){} 10.2. 用法 10.2.1. cin >> 连续从键盘读取想要的数据，以空格、tab 、换行为分隔符。 char a; int b; float c; string cin>>a>>b>>c; 当 cin >> 从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin>> 会将其忽略并清除，继续读取下一个字符; 若缓冲区为空，则继续等待。但是如果读取成功，字符后面的 空白符号 是残留在缓冲区的，cin>> 不做处理。 不想略过空白字符，那就使用 noskipws 流控制。 cin >>的返回值为 cin ;当输入 EOF （windows:ctrl+z， Linux:ctrl+d）时， cin >> 会返回0。 int a; // 当输入 EOF 时，可以终止循环 while（cin >> a）{ } 10.2.2. cin.get() [!note|style:flat] 缓冲区没有东西时，会堵塞等待。 int get(); istream& get(char& var); istream& get( char* s, streamsize n ); istream& get( char* s, streamsize n, char delim); 读取字符 : #include using namespace std; int main() { char a; char b; a=cin.get(); cin.get(b); cout 从输入缓冲区读取单个字符时不忽略分隔符，直接将其读取。 读取行 istream& get(char* s, streamsize n) istream& get(char* s, size_t n, char delim) s ，接收字符串用的数组 n ，读取个数。实际读取个数为 n - 1 ，留了一个给 \\0 delim ，指定终止符 换行符(结束符)会被留在缓冲区， 但末尾其余空白符会被读取。 10.2.3. cin.getline（） 读取行 istream& getline(char* s, streamsize count); //默认以换行符结束 istream& getline(char* s, streamsize count, char delim); 换行符(结束符)会被清理掉， 但末尾其余空白符会被读取。 getline(cin,string,\"结束符\") 功能更强。传入的是 cin ，不是 stdin 10.3. cin 清空输入缓冲区 10.3.1. 方法一 istream &ignore(streamsize num=1, int delim=EOF); 跳过输入流中 num 个字符，或遇到终止符 delim 结束（包括终止符）。 ignore() 会阻塞等待，最好别用 EOF 做终止符。 num : 可以设置一个很大的数 #include numeric_limits::max(); 10.3.2. 方法二 fflush(stdin); 11. :: / : 11.1. :: 当局部变量与全局变量重名，可以修饰变量，访问全局变量。仅c++支持 int x; // Global x int main() { int x = 10; // Local x cout 在类之外定义函数 访问类的全局变量 class Test { public: static int x; }; int Test::x = 1; void main(){ Test::x; } 如果有多个继承，父类变量名重名，子类可以做区分。 两个命名空间重命名 访问内部类 #include using namespace std; class outside { public: int x; class inside { public: int x; static int y; int foo(); }; }; int outside::inside::y = 5; int main(){ outside A; outside::inside B; } 11.2. : foreach for(int item:vector){ } 继承 参数初始化列表 class Father{ public: Father(){ cout 11.3. 参数初始化列表 初始化父类的构造器 初始化const变量 初始化var &引用变量 class Father{ public: Father(){ cout 12. include #include<> :只从从标准库文件目录下搜索，对于标准库文件搜索效率快。 #include\"\" :首先从用户工作目录下开始搜索，对于自定义文件搜索比较快，然后搜索标准库。 13. type-3 13.1. 总结type-3 名称 作用 注意 typedef 给变量A赋予一个别名B 1)A当前作用域可以访问的 2)B只在当前作用域有效 typeid() 获取类型信息，也就是对象原始模板的信息 泛型 typename 1）声明泛型类型； 2）声明泛型内嵌类型 下面解释 13.2. typeid() // 查看类型 typedef int FUCK; int var; const type_info & infoInt = typeid(int); const type_info & infoDef = typeid(FUCK); const type_info & infoVar = typeid(var); // 查看信息 info.name(); // 类型原始模板的名称 info.hash_code(); // 类型原始模板的哈希码 // 查看两个类型是否一样 if(infoInt == infoDef) [!note|style:flat] 1 infoInt,infoDef,infoVar都是一样的，他们的原始模板都是int。 2 泛型识别类型 template void print(T& a){ if(typeid(a) == typeid(int)){ cout 3 无法确定继承原始类型，输出为Father；s被首先Father静绑定了。 class Father{}; class Son : public Father{}; int main(){ Father * s = new Son(); cout 13.3. typename 声明泛型类型 // 泛型 template class Test{ public: void print(const T & a){ cout test; test.print(10); return 0; } [!note|style:flat] Test test;是在编译时确定，属于静态绑定。 声明泛型内嵌类型 泛型：大前提 内嵌：在类的内部定义类型。 class Car{ public: // 类型别名 typedef float Speed; // 内部类 class Wheel{ }; }; 当使用泛型的内嵌类型定义变量时，需要利用typename进行说明，否则编译器不知道这个是类型还是static变量。 class Car{ public: // 类型别名 typedef float Speed; // 内部类 class Wheel{ }; static float price; }; template class PrivateCar{ public: // 定义变量 typename T::Speed v; typename T::Wheel wheels; float getPrice(){ // 变量 return T::price; } }; [!note|style:flat] 不用typename的列外情况 template class Derived: public Base::内部类型 { Derived(int x) : Base::内部类型(x) { ... } } 14. private/protected/public 14.1. 类的内部对外 [!note] 默认修饰为private 修饰成员 private protected public 外部能否访问 不行 不行 可以 14.2. 继承 [!note] 默认继承为private 14.2.1. 子类内部对父类的访问 修饰父类成员 private protected public 子类能否访问 不行 可以 可以 [!note|style:flat] 继承限定对子类访问父类，没有一丢丢的影响，访问权限和上面一样。 14.2.2. 子类的父类成员对外 修饰继承 private protected public 子类中的父类成员 public变private protected变private public变protected 保持原样 15. a = a + b与a += b 对于a = a + b而言，可以等价于： [!tip] temp = a; temp += b; a = temp; temp就是类型转换中的那个「常性中间变量」。 就效率而言a += b比较快。 "},"cpp/chapter/point_reference_withNum.html":{"url":"cpp/chapter/point_reference_withNum.html","title":"三、指针与引用","keywords":"","body":"指针与引用 1. 指针与引用 类型 储存 初始化 二次赋值 形式 指针 有储存空间 NULL 可以 类名 * 引用 无空间，别名 已有的对象 不行 类名 & [!note|style:flat] c语言没有引用机制，是靠c++扩展实现。 2. 引用 2.1. 引用的初始化 2.1.1. 函数变量 直接在定义变量的时候初始化： int b = 1; int & a = b; 2.1.2. 类变量初始 [!note|style:flat] 使用「初始化列表」进行初始化。 class Test{ public: int & a; Test(int &a) : a(a) { } }; 2.2. const引用 2.2.1. 概念介绍 [!tip] const int & d2 = d1 对于d2只是d1的别名；名义上d2并没有分配，内存地址与d1一摸一样； 「d2的值」并没有被放到「常量表里」；d1修改后，d2的值也更着改变 int d1 = 4; const int & d2 = d1; d1 = 5; // 此时，d2的值也是：5 2.2.2. 常量引用 [!tip|style:flat] 常量具有常性，只有const引用可以引用常量 const int & d1 = 5; 2.2.3. 隐蔽类型转换的引用 [!note|style:flat] d1是double类型，d2是int，d1赋值给 d2时，要先生成一个「带常性的临时变量」，然后用临时变量进行赋值，所以int& d2 = d1;错误。 double d1 = 1.1； // 错误 int& d2 = d1; // 正确 const int& d3 = d2; 3. 智能指针   通过库函数，管理对象指针。 std::auto_ptr : 废弃 unique_ptr: 对象只能一个指针持有。 // 初始化赋值 std::unique_ptr p1(new int(5)); // 移交所有权，p1将变无效 std::unique_ptr p2 = std::move(p1); // 滞后赋值 unique_ptr p3; p3 = unique_ptr(new string (\"You\")); shared_ptr: 多个指针指向相同的对象。内部会有一个指向计数器，当计数器变为0时，系统就会对这个对象进行销毁，线程安全。 // make_shared生成 std::shared_ptr p1 = std::make_shared(10); // 拷贝赋值 std::shared_ptr p2; p2 = p1; weak_ptr: 没有重载operator*和->，用于防止shared_ptr循环引用。 4. 野指针   野指针不是NULL指针，是未初始化或者未清零的指针，在程序中乱指。 指针变量没有被初始化 指针指向的内存被释放了，但是指针没有置NULL 指针越界 5. 指针与数组 5.1. 关系 类型 二次修改 参与运算 sizeof() 指针 可以 可以 指针的字节 数组 不行 可以 声明空间的字节 5.2. 数组 [!note|style:flat] 当定义了char s[10];时，s的真实类型应该为char * const s;，所以s不可修改。 在「形参」中，使用type name[] 与 type name[10]的形式接收数组，都会退化为type * name的形式，即name是当作指针处理了。 5.3. 数组稀奇古怪的初始化方式 方式 说明 注意 int a[10]; 局部变量：未初始化； 全局变量：初始化为0；static修饰：初始化为0 int a[10] = {0} 肯定初始化为0。 int a[10] = {1,2,4} 前三个按照设置初始化，后面全是0 int a[10] = {1,2,4,} 编译通过 只能多写一个, 凸(▔皿▔╬) int a[3] = {1,2,4,} 编译通过 凸(▔皿▔╬) int a[3] = {1,2,3,4} 编译报错 {}写入的初始值个数不能大于数组声明值 const int N = 10;int n[N]; 编译通过 非const的N编译不通过 #define N 10; int n[N]; 编译通过 5.4. 字符数组长度的计算 char str[20] = \"fuck you\"; // 计算字节数 sizeof(str); // 计算字符串的长度 strlen(str); [!note|style:flat] sizeof(类型)的计算值实在编译时，进行计算。以下计算是正确的。 int a[sizeof(int)]; "},"cpp/chapter/oop_withNum.html":{"url":"cpp/chapter/oop_withNum.html","title":"四、面向对象","keywords":"","body":"面向对象 1. 重载，重写，重定义 重载 overload: 同一个类中、函数名字相同、传参类型与数目不同。 覆盖 override: 实现父类virtual修饰函数，函数定义完全一样。覆盖了父类的虚函数。 重写 overwrite: 重定义父类函数，会屏蔽父类所有同名函数。 [!note|style:flat] 函数名相同就会屏蔽父类同名函数 注 : 用户能定义自己的C语言库函数，连接器在连接时自动使用这些新的功能函数。这个过程叫做重定向C语言库函数。 2. 虚函数 虚函数实现 带有虚函数的类都会持有一个虚函数表 继承带有虚函数父类的子类，会复制一份父类虚函数表，并根据自身实现情况修改虚函数表 继承多个有虚函数表的子类，会维护所有的父类虚函数表 实例化的对象，会持有一个指向虚函数表的指针 虚函数/纯虚函数 子类实现后算overwrite 虚函数: virtual修饰，父类实现 纯虚函数: virtual修饰，父类不实现，后面可有 = 0，纯虚函数的类为抽象类。 [!note|style:flat] 虚函数是动绑定，运行时确定。 3. 继承 当私有继承和保护继承时，父类指针(引用)无法指向子类。默认为私有继承。防止多重继承，出现属性多次定义，继承时，还要使用 virtual 进行修饰。 4. 重载/多态 多态: 父类与子类之间，父类可以接收不同子类，产生不同的行为。 virtual 修饰函数的 override：父类调用子类的实现。 该方式才实现多态。 无 virtual 修饰函数的 overwrite：父类调用父类的实现。 重载: 一个类里，同一名字的不同方法。 5. 构造/析构函数 构造函数 不声明为虚函数 先父类，后子类 默认构造函数，即无参构造函数。 析构函数 要声明为虚函数; 通过多态析构子对象时，才能正确调用子类析构 先子类，再父类 6. 静绑定与动绑定 静态类型：对象在声明时的类型，在编译期既已确定； 动态类型：通常是指针或引用所指对象的类型，是在运行期决定的； /* * A 类是声明，是obj的静态类型 * B 类是具体实例，是obj的动态类型 */ A* obj = new B(); 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期； 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；可以进行二次修改。 A* obj = NULL; obj->fcn();   上面的函数也是能正常运行的，因为obj在编译时静绑定。 7. 构造函数 普通构造函数: 不能以本类的对象作为唯一参数 默认拷贝构造函数: 对源对象的逐个字节的复制，成员变量和源对象相同，由编译器自动生成 拷贝构造函数：构造函数的一种，只有一个本类的引用的参数，用不用const修饰都一样。 调用拷贝构造函数，不调用普通构造: 一个对象去初始化同类的另一个对象，赋值不会触发。 A a; // 初始化 A b = a; A c(a); // 赋值 b = a; 作为形参的对象，是用复制构造函数初始化的。直接传递对象，传过去的值，取决于构造函数的实现。 return 语句所返回的对象 8. 动多态与静多态 类型 实现方式 确定时间 动多态 继承与override 运行时 静多态 泛型 编译 9. 拷贝构造与赋值 拷贝构造函数 一种特殊的构造函数 复制的对象还不存在，正在为对象初始化一块内存区域，利用复制值进行初始化。 赋值 一种函数操作 赋值的对象已经存在，用复制值来覆盖原来的值。 [!note|style:flat] 默认拷贝构造与默认赋值，均是原封不动的拷贝目标对象的值；对于指针也是直接拷贝指针的地址内容，会造成隐患。 正确的赋值 检查是否为同一个 指针内存是否要释放 指针变量，对指向值进行拷贝。 //赋值函数 string & string::operator=(const string& other) { if(this == &other) //自我检查 { return *this; } //删除原有数据内存 delete []m_data; int strlen = strlen(other.m_data); m_data = new char[strlen +1]; strcpy(m_data ,other.m_data); return 8this; } [!note|style:flat] T & operator=(const T & other) 返回了原对象，则串行赋值，是正确的。 class Test{ public: int a; }; Test a1,b1,c1; // 串行赋值 a1 = b1 = c1; // 修改返回值 修改的是 a1 的值 (a1 = b1).a = 12; "},"cpp/chapter/memory_withNum.html":{"url":"cpp/chapter/memory_withNum.html","title":"五、内存","keywords":"","body":"内存 1. 代码内存分布 内存空间 存放内容 读写权限 内核空间 操作系统运行的内存空间。栈，堆。。齐全 应用程序不能直接操作 栈 函数局部变量，形参 读/写 堆 new/malloc申请空间 读/写 全局的数据空间 全局变量，static变量。包括初始化化的（data），未初始化的（bss）。 读写 只读数据段 \"fuck you\"等字符串常量 读 代码段 程序代码最终的指令集 读 2. 内存泄露/栈溢出 内存泄露: 堆使用了，没清空，内存大量浪费 栈溢出: 使劲增加局部变量，栈用完了 3. 字符存储编码 ASCII 码: 使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。 BCD码: （Binary-Coded Decimal‎）亦称二进码十进数或二-十进制代码。用4位二进制数来表示1个十进制数中的0~9这10个数码。 内码: 指汉字系统中使用的二进制字符编码。 4. 字节对齐 4.1. 介绍 4.1.1. 概念 内存空间按照字节划分，在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。 4.1.2. 原因 不同硬件平台对存储空间的处理上存在很大的不同。某些平台对特定类型的数据只能从特定地址开始存取，不能任意存放数据。 不按照平台要求对数据存放进行对齐，会带来存取效率上的损失。例如：一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问。 说白了就是为了CPU读写数据时，统一规则，能一大块一大块的拿，节约时间。 4.2. 字节对齐计算 4.2.1. 字节对齐值 [!note] 数据类型「自身对齐值」：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。 结构体或类的「自身对齐值」：max(成员中自身对齐值) 指定对齐值：#pragma pack (对齐值) 结构体和类的「有效对齐值」：min{类，结构体自身对齐值，当前指定的pack值}。 数据成员的「有效对齐值」：min{成员自身对齐值，当前指定的pack值} 默认对齐值 ：64位，8字节；32位，4字节。 4.2.2. 字节对齐准则 [!warning|style:flat] 有效对齐值N最终决定数据存放地址方式。表示「对齐在N上」，即存放的起始地址满足 起始地址 % N == 0 数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。 类，结构体的成员变量要对齐存放 结构体本身也要根据自身的「有效对齐值」圆整， 即结构体成员变量占用总长度为结构体「有效对齐值」的整数倍，不足也要补足。 4.2.3. 储存字节计算 #pragma pack() struct TestA{ char ch; int i; double d; const char cch; }; struct TestB{ char chb; struct TestA a; int ib; }; #pragma pack() // 缺省，恢复默认的对齐字节 int main(void){ struct TestB b; printf(\"amount: %d\\n\",sizeof(b)); printf(\"b.a: %d\\n\", (unsigned int)(void*)&b.a - (unsigned int)(void*)&b); printf(\"b.a.ch: %d\\n\", (unsigned int)(void*)&b.a.ch - (unsigned int)(void*)&b); printf(\"b.a.i: %d\\n\", (unsigned int)(void*)&b.a.i - (unsigned int)(void*)&b); printf(\"b.a.d: %d\\n\", (unsigned int)(void*)&b.a.d - (unsigned int)(void*)&b); printf(\"b.a.cch: %d\\n\", (unsigned int)(void*)&b.a.cch - (unsigned int)(void*)&b); printf(\"b.ib: %d\\n\", (unsigned int)(void*)&b.ib - (unsigned int)(void*)&b); return 0; } triangle@DESKTOP-RDTVBUO:/mnt/c/Users/GOD/Desktop/test/testcpp{% math_inline %} ./a.out amount: 40 b.a: 8 b.a.ch: 8 b.a.i: 12 b.a.d: 16 b.a.cch: 24 b.ib: 32 triangle@DESKTOP-RDTVBUO:/mnt/c/Users/GOD/Desktop/test/testcpp{% endmath_inline %} 对TestB的储存结构进行说明： 1. 64位系统，默认对齐字节8； 2. char chb：char的自身对齐值min{1,8}，所以存储地址首地址0 % 1 == 0成立。 3. TestA a：double d;字节数最大，所以其「自身对齐值」为8，有效对齐值为min{8,8}，存储地址首地址 8 % 8 == 0 成立。 ===开始对TestA a内部字节8 ~ 31进行划分。=== 1. char ch;：就按照TestA a首地址往下存。 2. int i;：int的自身对齐值min{4,8}，所以存储地址首地址12 % 4 == 0成立。 3. double d;：double的自身对齐值min{8,8}，所以存储地址首地址16 % 8 == 0成立。 4. const char cch;：char的自身对齐值min{1,8}，所以存储地址首地址24 % 1 == 0成立。 5. 由于TestA a的「有效对齐值」为 min(8,8) ，根据「圆整准则」TestA a 的大小必须为 n*8 ，所以最后的 25 ~ 31 为编译器填充。 ===对TestB进行最后圆整收尾=== 1. 对于TestB而言成员最大的对齐值是TestA a ，「有效对齐值」为 min(8,8) ，所以TestB 的大小必须为 n*8 ，最后进行了 36 ~ 39 的填充。 4.2.4. # pragma pack() [!note] # pragma pack(对齐值):可以重新定义默认的对齐字节值，计算方法就是3.中的默认值替换掉，然后同上计算。 对齐值只能为 2n2^n2n 。 # pragma pack(): 缺省，表示使用默认。 # pragma pack(push): 将当前对齐字节值保存 # pragma pack(pop): 将保存的对齐字节值弹出 4.3. 字节对齐的隐患 4.3.1. 问题 // 案列一 int main(void){ unsigned int i = 0x12345678; unsigned char *p = (unsigned char *)&i; *p = 0x00; unsigned short *p1 = (unsigned short *)(p+1); return 0; } // 案列二 void Func(struct B *p2){ //Code } [!note|style:flat] 案列一：p1访问内存数值时，由于指向为奇数，对于32位会降低速度，对于特殊CPU则会异常。 案列二：p2如果是跨CPU访问，对齐要求不同，也会导致异常。 4.3.2. 解决方案 [!tip|style:flat] 对于案列二，可以选择修改对齐方式，然后重新赋值，让编译器解决。 #pragma pack(对齐值) void Func(struct B *p){ struct B tData; memmove(&tData, p, sizeof(struct B)); //此后可安全访问tData.a，因为编译器已将tData分配在正确的起始地址上 } 规划好字节排序： 同一类型尽量放一起 默认对齐字节整数倍大小的紧凑放最前 接着放能够凑成默认对齐字节大小的 不够默认对齐字节的放最后，并添加几个填充字符。 typedef struct tag_T_MSG{ // 默认对齐字节大小 int ParaA; int ParaB; // 凑默认对齐字节大小 short ParaC； char ParaD; //填充字节 char Pad; }T_MSG; 4.4. 默认对齐字节的由来 4.4.1. 内存的结构 一个内存是由若干个「黑色的内存颗粒」构成；一个内存颗粒叫做一个「chip」；每个「chip」内部，是由8个「bank」组成的；每一个「bank」是一个二维平面上的矩阵，每一个元素中都是保存了1 byte，也就是8 bit。 4.4.2. 内存地址 内存地址编号： 一个地址编号对应一个字节，对于地址0x0000-0x0007地址，是在第一个「chip」上，是由重叠的8个「bank」相同位置上的元素从bank0 ~ bank7进行编号，8个「bank」是可以并行工作，加快读写速度。 8个「bank」： 64位cpu对内存的一次操作只能操作8 byte，因为64位cpu的寄存器是64位的，只能放8 * 8 bit的值。 4.4.3. 字节对齐默认值 [!note|style:flat] 64位的cpu，默认对齐字节为8， 这就能保证，小于等于8字节的数据存储位置，是cpu能一次操作就能成功获取完毕的。 假如: 你指定要获取的是0x0005 ~ 0x0009的数据：内存只好先工作一次把0x0000-0x0007取出来，然后再把0x0008-0x0000f取出来，最后再把两次的结果合并，把最终结果返回。 同理32位的cpu默认对齐字节位4，因为32位cpu的寄存器是32位的。 5. 类/结构体的内存分布 5.1. 类 一个类在内存中的组成： 若有virtual方法：第一个为vptr，所占字节数根据操作系统来：64位：8 byte，32位：4 byte。 非static变量 ，static变量在静态区。 const变量也在里面，虽然编译器会对常量进行优化放到常量表，但是根还在这儿。 对象变量指向第一个内存位置的地址 属性存放顺序与定义顺序一样 5.2. 子类 [!note] 父类的若有vptr 就放第一个， 接着是父类的非static属性 最后放子类的属性 防止多重继承，出现属性多次定义，继承时，使用 virtual 进行修饰。 5.3. 结构体 与类一样。唯一不同点，就是没有vptr。 5.4. 字节计算 类：sizeof(vptr) + 5.2的结果；sizeof(vptr)由操作系统定，64位，8 byte；32位，4 byte 结构体：5.2的结果 在64位操作系统，sizeof(TestB)的大小为24。 class TestA{ public: const int b; virtual void fcn(){} }; class TestB{ public: int c; TestA a; }; 6. 对象与类 类型 描述 储存 类 模板，包括属性和行为 无 对象 类的实例化，主要是数据的集合 主要只储存了属性，储存位置看具体情况 ; 函数放代码段，所有对象通用 [!warning|style:flat] 类的概念没有占用内存，但是sizeof(类名)是有值的，等于sizeof(实列)计算结果。 7. 8 代码地址 运行时地址起始位置：它芯片公司指定的一开始运行代码的位置。 运行地址: 就在从运行时地址起始位置（包括起始位置）往后排都是运行时地址。(程序代码被搬过来执行) 链接地址起始位置：链接脚本设定，这个位置在程序链接之后，就会确定下来。(用来计算偏移量的伪地址，之后重定向) 链接地址: 就是从链接地址起始位置（包括起始位置）往后排都是链接地址。(类似汇编地址) 加载地址: 从flash的那个地方开始读取程序，加载内存中去。 存储地址: 程序存储在哪儿的。 "},"cpp/chapter/process_withNum.html":{"url":"cpp/chapter/process_withNum.html","title":"六、进程与线程","keywords":"","body":"进程与线程 1. 进程 1.1. 程序操作 1.1.1. 创建   创建的是原进程的子进程，子进程会复制父进程的PCB(进程控制块)，二者之间代码共享，数据独有，拥有各自的进程虚拟地址空间。 #include pid_t fork(void); 写时拷贝技术  子进程创建后，与父进程映射访问同一块物理内存，当父或子进程对值进行修改时，会给子进程重新在物理内存中开辟一块空间，并将数据拷贝过去。 pid_t: 创建子进程失败，会返回-1; 创建子进程成功，父进程返回pid号，子进程返回0。 1.1.2. 终止 正常终止 main函数返回 调用exit函数: status 可以通过 wait（int *status） 接收; 会刷新缓冲 #include void exit(int status); 调用_exit函数: status 可以通过 wait（int *status） 接收; 不会刷新缓冲 #include void _exit(int status); 异常退出 Ctrl+C 被信号终止 1.1.3. 等待   如果子进程先于父进程退出，而父进程并没有关心子进程的退出状况，从而无法回收子进程的资源，就会导致子进程变成僵尸进程。进程等待的作用就是父进程对子进程收尸！父进程通过进程等待的方式，回收子进程的资源，获取子进程的退出状态。 wait #include #include pid_t wait(int *status); 利用阻塞，等待子进程退出。 一次只能等待一个 pid: 成功，子进程的pid; 失败(没有子进程)，返回-1; status: 进程退出信息 waitpid //头文件同wait的头文件 pid_t waitpid(pid_t pid, int *status, int options); 返回值: 等待成功，返回pid options为WNOHANG时，没有等待到子进程，马上退出不阻塞，返回0 出错则返回-1 pid: -1: 随便等待一个进程 pid号: 明确指定一个进程等待 options: 0: 阻塞等待，等待到一个就退出 WNOHANG: 没有等待到子进程，马上退出不阻塞，返回0 1.1.4. 进程退出信息status 低16位存放信息，高16位不用 高8位 : 退出码， exit 的传入值或者 return 值 (status >> 8) & 0xFF; 低8位 : 异常退出信息 第7位: core dump标志位;0，不产生;1，产生 (status >> 7) & 0x1; 低7位: 子进程是否异常退出;0，正常;非0，终止的信号 status & 0x7F; 1.2. 进程状态 1.2.1. top指令查看： R (running): PCB被放入CPU的可执行队列中;CPU上执行的RUNNING状态、而将可执行但是尚未被调度执行的READY状态 S (sleeping): 睡眠状态，PCB被放入等待队列，可以通过中断唤醒。 D (disk sleep):睡眠状态，不能中断被唤醒。内核的某些处理流程是不能被打断的。用来保护进程。 T (stopped): SIGSTOP信号让进程进入暂停，SIGCONT信号能将进程恢复。 t (tracing stop): 在被追踪时，进程暂停;典型应用就是 gdb断点 。调试进程退出，被调试的进程才能恢复TASK_RUNNING状态。 Z (zombie): 进程退出后，PCB没有被回收。父进程没有对子进程收尸，就只能等父进程退出后，让爷进程来统一收尸。 X (dead): 马上会被彻底销毁 1.2.2. 执行时的状态： 进程主要有三种状态：运行态、就绪态、阻塞态。 「运行态」和「就绪态」可以相互转换，通常由系统的进程调度引起的。 遇到阻塞代码，进程进入「阻塞态」，等待被唤醒；没有足够的运行资源时，进程会被挂起，进入「阻塞态」等待资源充足。 进程由「阻塞态」被唤醒，就会进入「就绪态」，等待被调度。 1.3. 进程状态变化 `R`变非`R`状态。 非`R`变`R`状态 1.4. 进程间通信 1.4.1. 管道 父子进程间通讯。 1.4.2. 命名管道 去除了父子进程间通信的机制，通常用来汇聚多个客户端进程与服务端进程的通信。 1.4.3. 消息队列 独立于进程存在，进程间可以通过消息队列来传递数据，典型的模式是生产者-消费者模型。 1.4.4. 信号 一个进程可以给另一个进程发送信号SIGN来触发某些操作。 1.4.5. 共享内存 多个进程上不同的地址空间可以映射到同一块物理内存上，实现数据的共享。因为不涉及数据的拷贝，所以这是一种高效的通信方式。需要注意的是，多个进程并行时，需要通过同步机制保护共享内存的访问。 1.4.6. Socket 通信 TCP与UDP通讯协议。 1.4.7. 信号量 用来统计资源数量的。 整型信号量 0: 繁忙，没有资源可用。 > 0: 资源有空闲。 不能为负值 记录型信号量 0: 繁忙，没有资源可用，也没有人过来等待资源。 > 0: 资源有空闲。 : 没资源，等待队列下有人在那儿等着。 1.5. 僵尸进程和孤儿进程 僵尸进程： 父进程运行完毕，没有对「已经退出的子进程」进行收尸。 孤儿进程： 当父进程退出了，但是它的「子进程还没有退出」，这些子进程就变成了孤儿进程。孤儿进程只是暂时的，系统会在父进程退出时启动寻父机制，为子进程找到一个新的父亲。 1.6. 进程同步 进程同步： 进程同步是指控制进程按照一定顺序执行。只有处于临界区（指访问共享内存的代码片段）的进程才需要同步。 忙等待互斥（自旋锁）：当某个变量不满足条件时，会一直轮询直到变量值发送改变。用于忙等待的锁称为自旋锁。 信号量： 是一个整型变量，用来实现计数器功能，主要提供 down 和 up 操作（即 P 和 V 操作），这两个操作都是原子性的。当执行 down 操作使信号量值变为 0 时，会导致当前进程睡眠，而执行 up 操作 +1 时，会同时唤醒一个进程。 管程： 管程是由一个过程、变量和数据结构组成的一个集合，把需要控制的那部分代码独立出来执行，它有一个重要的特性，同一时刻在管程中只能有一个活跃的进程。为了避免一个进程一直占用管程，引入了条件变量和 wait 和 signal 操作。当发生当前进程无法运行时，执行 wait 操作，将当前进程阻塞，同时调入在管程外等待的另一进程执行，而另一个进程满足条件变量时，会执行 signal 操作将正在睡眠的进程唤醒，然后马上退出管程。 改造线程互斥锁： 这个得看系统支不支持。 2. 线程与进程 线程：进程中活动的对象，在 CPU 上被实际调度的实体对象，独立调度的基本单位。线程都拥有一个独立的程序计数器、线程堆栈内容和寄存器值。 进程: 资源分配的基本单位。包括可执行的代码、打开的文件描述符、挂起的信号、进程的状态、内存地址空间、存放全局变量的数据段，以及一个或多个执行线程等。 3. 线程 3.1. 线程的意义 在一个进程中会存在多种活动任务，需要有多个独立调度的单元来使这些任务可以并行的执行，这些单元就是线程。 线程比进程更轻量，它们比进程更快的创建，也更容易撤销。线程间切换的开销也比进程小，由于进程拥有大量的资源，当切换到另一个进程的时候，需要保存当前进程的所有资源，而线程间的切换只需要保存当前堆栈和相应寄存器的内容。 3.2. 线程同步 互斥锁： pthread_mutex_那一套 条件量： 引入信号机制，优化后的抢锁机制。 信号量： 同进程。 自旋锁： 同进程。 4. 并发和并行 并发： 一段时间内可以同时运行多道程序，对于CPU而言就是程序来回切换。 并行： 多个CPU同时运行程序，真正物理上的并发。 "},"cpp/chapter/locks_withNum.html":{"url":"cpp/chapter/locks_withNum.html","title":"七、锁","keywords":"","body":"锁 参考博客： 你说说互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景 CAS原理 什么是乐观锁，什么是悲观锁 经典的ABA问题与解决方法 1. 为什么要锁 高并发的场景下，线程（进程）胡乱使用「公共资源」，会造成资源混乱，没有做好并发控制，就可能导致「脏读、幻读和不可重复读」等问题。「锁」便是用来控制进程（线程）有序利用「公共资源」的手段。 如果选择了错误的锁，那么在一些高并发的场景下，可能会降低系统的性能。 2. 互斥锁与自旋锁 [!note|style:flat] 作用：当已经有一个线程加锁后，其他线程加锁则就会失败 地位：最底层的两种锁，其他高级锁都是靠这两种锁演变而来 区别 「互斥锁」加锁失败后，线程会释放 CPU ，给其他线程 「自旋锁」加锁失败后，线程会忙占用 CPU，直到它拿到锁 2.1. 互斥锁 互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，线程 B 加锁的代码就会被阻塞。 对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。内核会将线程置为「睡眠」状态，等到锁被释放后，内核会唤醒线程，线程 B成功获取到锁后继续执行，否则继续阻塞。 互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。 [!tip|style:flat] 两次线程上下文切换的成本 当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行； 当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。 上下文切换了啥？ 虚拟内存资源是进程申请的，这个线程管不着，但是线程运行用的栈、寄存器是得靠自己维护： 从cpu切换出去时，需要把自己的堆栈、寄存器进行备份处理 把线程加载回cpu时，又需要把备份的堆栈、寄存器进行恢复，这样线程程序才能正常执行。 如果锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长 2.2. 互旋锁 自旋锁：在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。 [!tip] 锁运行流程 查看锁的状态 锁空闲：将锁设置为当前线程持有。「完成加锁操作」 锁繁忙：线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 while 循环等待实现，不过最好是使用 CPU 提供的 PAUSE 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。「加锁失败」 注意： 在单核 CPU上，需要「抢占式的调度器」（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。(不能让「自旋锁」占着茅坑不拉屎，单核CPU不工作了。) 自旋的时间和被锁住的代码执行的时间是成「正比」的关系 3. 读写锁 3.1. 概念 读写锁：由「读锁」和「写锁」两部分构成；只「读取」共享资源用「读锁」加锁，「修改」共享资源则用「写锁」加锁。读写锁适用于能明确区分读操作和写操作的场景。 [!tip] 「读锁」: 当「写锁」没有被线程持有时，多个线程能够并发地持有「读锁」。只要没人「写」，大家都能来「读」，不存在互斥。 「写锁」：独占锁（可以利用「互斥锁和自旋锁实现」），一旦有线程持有了「写锁」，想要「读」的线程和想要「写」的线程都被「堵塞」，只允许持有「写锁」的线程修改「公共资源」。 3.2. 读优先锁 [!tip] 优先服务于「读」的线程操作。 首先，读线程A进入，拿到「读锁」开始读 然后，写线程B进入，抢「写锁」失败，被堵塞 最后，读线程C进入，仍然可以拿「读锁」开始读。 只有「读线程」全部操作完成释放了所有「读锁」，「写线程」才能继续抢锁。 3.3. 写优先锁 [!tip] 优先服务于「写」的线程操作。 首先，读线程A进入，拿到「读锁」开始读 然后，写线程B进入，抢「写锁」失败，被堵塞 最后，读线程C进入，拿「读锁」失败，被堵塞，因为「写线程B」还没完成工作，读线程C被叫停。 只有「读线程A」释放了「读锁」，「写线程B」拿到「写锁」完成写操作后，「读线程C」才能继续读。 3.4. 公平读写锁 对于「优先读」方案，当「读线程」进来得太多，「写线程」就一直等着，没法工作，就会造成写线程「饥饿」。同样，对于「优先写」方案也是一样，会造成读线程「饥饿」。 为了防止「饥饿」的产生，可以采用「公平读写锁」方案：用「队列」把获取锁的线程排队，不管是写线程还是读线程都按照「先进先出」的原则加锁即可，这样读线程仍然可以并发。 4. 乐观锁与悲观锁 4.1. 对比 类型 描述 应用 悲观锁 假设：多线程同时修改共享资源的概率比较高，容易出现冲突 结果：访问共享资源前，先要上锁。 互斥锁 自旋锁 读写锁 乐观锁 假定：多线程同时修改共享资源的概率比较低，不容易冲突 结果：先修改完共享资源，再验证这段时间内有没有发生「冲突」，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。 git 4.2. 乐观锁 实现方式 CAS 实现：Compare And Swap对比之后交换数据 版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会 +1。当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。 CAS实现原理 [!note|style:flat] 三个数据：内存位置(V)、原值(A)和新值(B) 运行逻辑：如果内存位置V的值与原值A一样时，就将内存位置V修改为新值B，否则什么都不做。 竞争处理：通过CAS校验完成新值提交的线程竞争成功，否则竞争失败；对于失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次发起尝试。 /** * 校验成功：返回true，并提交新值 * 校验失败：返回false，放弃新值 */ bool cas(V,A,B){ // 如果内存 V 的值没有被修改 if(*V == A){ // 提交 B *V = B; return true; }else{ return false; } } // 共享资源 share *V; void threadRun(){ do{ // 备份内存v的值 A = *V; // 得到新值 B = getB(); }while(!cas(V,A,B)); } [!tip] 优点 对死锁问题天生免疫 要比基于锁的方式拥有更优越的性能 加大了数据吞吐量 缺点 cas方法只对「公共资源」的前后结果进行了比较，并不清楚「公共资源」的修改过程，因此会导致「ABA问题」 ABA问题 此时，线程1与线程2需要对资源（黄色方框代表资源V）进行修改操作；两个线程开始时备份的原始值都是A；线程1运算得快，首先提交修改将资源修改为B，这时线程2还在运算中；这时突然来了个第三者额外事务，将资源值又重新修改回了A；这样的情况下，等到线程2执行完毕，进行CAS检验成功完成提交，将资源修改为了C。这就造成了「ABA问题」。 [!note|style:flat] 资源不一定是被「外部事务」修改A，还可以是线程1先把资源修改为B后提交，又紧接着执行了一次把值给修改为了A。 案列： 一家火锅店为了生意推出了一个特别活动，凡是在五一期间的老用户凡是卡里余额小于20的，赠送10元，但是这种活动没人只可享受一次。然后火锅店的后台程序员小王开始工作了，很简单就用cas技术，先去用户卡里的余额，然后包装成AtomicInteger，写一个判断，开启10个线程，然后判断小于20的，一律加20，然后就很开心的交差了。可是过了一段时间，发现账面亏损的厉害，老板起先的预支是2000块，因为店里的会员总共也就100多个，就算每人都符合条件，最多也就2000啊，怎么预支了这么多。小王一下就懵逼了，赶紧debug，tail -f一下日志，这不看不知道，一看吓一跳，有个客户被充值了10次! 问题： 假设有个线程A去判断账户里的钱此时是15，满足条件，直接+20，这时候卡里余额是35.但是此时不巧，正好在连锁店里，这个客人正在消费，又消费了20，此时卡里余额又为15，线程B去执行扫描账户的时候，发现它又小于20，又用过cas给它加了20，这样的话就相当于加了两次，这样循环往复肯定把老板的钱就坑没了！ [!note|style:flat] 解决思路：增加一个version变量，进行「版本控制」，具体实现见上面「版本控制」所述。 5. 死锁 参考视频：b站最新的死锁和解决方案 5.1. 定义 [!note] 死锁：指多个进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象（互相挂起等待），若无外力作用，它们都将无法推进下去。 [!tip|style:flat] 线程A持有了锁A；线程B持有了锁B 线程A想要锁B；线程B想要锁A 线程A不放手锁A，等锁B；线程B不放手锁B，等锁A 5.2. 死锁原因 [!note] 术语版本 互斥条件 临界资源只能一个进程(线程)使用。 占有和等待条件 进程在请求资源得不到满足而等待时，不释放已占有资源。 不剥夺条件 已获资源只能由进程自愿释放，不允许被其他进程剥夺 循环等待条件 每个进程都在等待链中等待下一个进程所持有的资源 人话版本 m >= 2个线程（进程）争夺n >= 2个资源，并且m >= n 进程（线程）去争夺资源的顺序不一样（会导致循环等待） 自己拿不到需求的资源，不放手 5.3. 死锁后果 [!note|style:flat] 大家都别玩，都在那儿等着，程序卡死不运行。 5.4. 解决死锁 [!tip] 三种解决方法： 死锁防止：打破四个必要条件中的一条 死锁避免：银行家算法 死锁检测和恢复：检测到死锁出事了，采取措施进行恢复。 5.5. 死锁防止 1. 破坏互斥条件 对于「只读」资源，可以不用锁进行资源管理。 2. 破坏占有和等待条件 静态分配的方式：进程必须在执行之前就申请需要的全部资源，且直至所要的资源全部得到满足后才开始执行。(资源管够，大家都别抢。) 3. 破坏不剥夺条件 方法一：占有资源的进程若要申请新资源，必须主动释放已占有资源，若需要此资源，应该向系统重新申请。 方法二：资源分配管理程序为进程分配新资源时，若有则分配；否则将剥夺此进程已占有的全部资源，并让进程进入等待资源状态，资源充足后再唤醒它重新申请所有所需资源。 4. 破坏循环等待条件 给系统的所有资源编号，规定进程请求所需资源的顺序必须按照资源的编号依次进行。(大家按照规定顺序拿资源。) "},"cpp/chapter/stl_withNum.html":{"url":"cpp/chapter/stl_withNum.html","title":"八、STL","keywords":"","body":"STL 1. 简介   STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。 数据结构和算法的分离 不是面向对象的 STL库的实现包含了「泛型函数」和 「泛型类」； STL算法的实现只包含了「泛型函数」 主要构成有六大组件: 容器（Container） 迭代器（Iterator） 算法（Algorithm） 仿函数（Functor） 适配器（Adaptor） 分配器（allocator） 2. 容器（Container） 序列式容器（Sequence containers） Vector: 动态数组 Deque: 双端队列，是一种具有队列和栈的性质的数据结构。元素可以从两端弹出，其限定插入和删除操作在表的两端进行。 List: 双向链表 关联式容器（Associated containers) Set/Multiset: Set内的相同数值的元素只能出现一次; Multisets内可包含多个数值相同的元素。 Map/Multimap: map只允许key唯一；multimap中key可以重复使用； [!note|style:flat] set map multiset multimap 通过红黑实现，无序 unorder_map unorder_set 通过哈希表实现。 3. 分配器 容器类自动申请和释放内存，无需new和delete操作。 4. 迭代器 遍历数据用的。 支持运算符: *;+＋;＝＝;！＝;＝ 。 指针操作 Container c; Container::iterator it; for(it=c.begin();it!=c.end();it++){ // vector 获取值 *it; // map 获取键值对 it->first; it->second; } 带迭代器的容器遍历 // 只读 for(auto item:containers){ } // 可修改 能修改的值 for(auto& item:containers){ } 5. 算法 5.1. 头文件   算法部分主要由头文件，和组成。 : 由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。 : 只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。 : 中则定义了一些模板类，用以声明函数对象。 5.2. 常用算法    STL常用算法 6. 仿函数    钩子函数，可以当参数传递，让具体算法进行调用。 系统定义好的仿函数: 函数指针实现 仿函数实现: 定义一个简单的类 实现 operator() 操作符，本质上就定义了一个符号函数。 #include #include #include class Compare{ public: bool operator()(int a,int b){ return a > b; } }; int main(int argn,const char* args[]){ vector vec(5,1); vec[0] = 2; vec[1] = 1; vec[2] = 9; vec[3] = 3; vec[4] = 1; // 排序算法 sort(vec.begin(),vec.end(),Compare()); // 实际的函数调用 bool flag = Compare()(10,12); } [!note|style:flat] 注意： Compare()是定义了一个临时对象，作为参数传递给了 sort()；若sort()没有采用引用传递，则对象将是值传递。 7. 容器适配器   对基础容器进行功能扩展，标准库提供了三种顺序容器适配器: queue(FIFO队列) stack(栈) priority_queue(优先级队列) 容器 头文件 默认容器 可选容器 说明 queue deque list、deque 基础容器必须提供push_front()运算 priority_queue vector vector、deque 基础容器必须提供随机访问功能 stack deque vector、list、deque "},"cpp/chapter/dataStruction_withNum.html":{"url":"cpp/chapter/dataStruction_withNum.html","title":"九、数据结构","keywords":"","body":"数据结构 1. 字符串 1.1. c风格 字符串结尾标志为 \\0 \" \" : 自带 \\0 strcpy，strncpy 不会在末尾加 \\0，dest还得手动加终止 strcat : 会自动加 \\0 #include // 创建 char str[] = \"RUNOOB\"; char *str = \"fuck you\"; char str[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\\0'}; // 拷贝字符串 strcpy(char *dest, const char *src); // 将src拷贝到dest，拷贝以 \\0 作终止; char *strncpy(char *dest, const char *src, size_t n); // n指定长度，更安全 // 拼接字符串 char *strcat(char *dest, const char *src); // 往dest上加字符串 // 字符串长度 strlen(str); // \\0 终止 // 比较字符串 int strcmp(const char *s1, const char *s2); // 相同返回 0 // 查找 char *strchr(const char *str, int c); //返回第一个字符位置，没有返回NULL char *strstr(const char *haystack, const char *needle); // 返回第一个字符串位置，没有返回NULL 1.2. c++字符串 string 是一个对象 string 的结尾没有结束标志 \\0 == 可以用来判断字符串是否相同 #include // 创建 string str; // s1的值为NULL string str = \"c plus plus\"; string str(c风格); // 字符串长度 str.length(); // 转c风格 str.c_str(); // 访问字符 str[i]; // 数字转字符串 string to_string(int value); string to_string(long value); string to_string(double value); // 字符转数字 atoi(const char*); stoi(const string&); strtoi(const char *); // 插入 string& insert (size_t pos, const string& str); // 删除 string& erase (size_t pos = 0, size_t len = npos); // 获取子串 string substr (size_t pos = 0, size_t len = npos) const; // 查找 返回第一个找到的位置，没找到返回一个无穷数 size_t find (const string& str, size_t pos = 0) const; size_t find (const char* s, size_t pos = 0) const; find_first_of(const string& str); // 子字符串和字符串共同具有的字符在字符串中首次出现的位置 2. 栈 stack 没有迭代器功能。 #include #include stack s; stack > stk; //覆盖基础容器类型，使用vector实现stk s.empty(); //判断stack是否为空，为空返回true，否则返回false s.size(); //返回stack中元素的个数 s.pop(); //删除栈顶元素，但不返回其值 s.top(); //返回栈顶元素的值，但不删除此元素 s.push(item); //在栈顶压入新元素item 3. 队列 queue 没有迭代器功能。 queue q; //priority_queue q; q.empty(); //判断队列是否为空 q.size(); //返回队列长度 // 出队和入队 q.push(item); //对于queue，在队尾压入一个新元素 q.pop(); //删除 queue 中的第一个元素 // 队列访问 q.front(); //返回队首元素的值，但不删除该元素 q.back(); //返回队尾元素的值，但不删除该元素 4. vector 4.1. 底层实现 [!tip] vector是一个可以动态扩容的「数组」。_Myfirst 指向的是 vector 容器对象的起始字节位置；_Mylast 指向当前最后一个元素的末尾字节；_myend 指向整个 vector 容器所占用内存空间的末尾字节。 #include // 创建 vector vec; vector vec(int nSize); // 指定容器初始大小 vector(int nSize,const T& initValue):// 指定容器初始值 // 增加 vec.push_back(const T& item); // 在屁股添加 iterator vec.insert(iterator it,const T& item); // 迭代器指定位置插入元素 // 删除 vec.pop_back(); // 删除屁股 iterator erase(iterator it); // 删除迭代器指定位置元素 vec.clear(); // 删除全部 // 查找 vec[i]; vec.at(i); // 会检查是否越界，提高稳定性 // 容器内储存元素个数 vec.size(); // 容器是否有东西 vec.empty(); // 迭代器位置 vector::iterator it = vec.begin(); // 起始位置 vector::iterator it = vec.end(); // 结束位置 int a = *it; //获取值 *it += 1; // 定义二维数组 vector > obj(row); // row定义行数 4.2. 内存管理 4.2.1. 内存属性 size = _Mylast - _Myfirst: 数据真正存储了多少个。 capacity = _Myend - _Myfirst：预分配的内存空间。 vector::size(); // 获取 size vecotr::capacity(); // 获取 capacity 4.2.2. 内存修改 reserve(int)： 仅仅只修改capacity，但不会真正的创建对象。 resize(int)： 分配了空间，也创建了对象。默认初始化为0。同时修改了size和capacity 4.2.3. 内存扩展 当size == capacity时，表示vector申请的内存已经被存储完了，需要进行内存扩张： 完全弃用现有的内存空间，重新申请更大的内存空间； 将旧内存空间中的数据，按原有顺序移动到新的内存空间中； 最后将旧的内存空间释放。 [!note|style:flat] vector 容器在进行扩容后，与其相关的指针、引用以及迭代器可能会失效。 4.3. 排序 > : 从大到小排序 : 从小到大排序，默认方式 class Compare{ public: // 对象最好用引用进行传递 bool operator()(T const & a,T const & b){ return a > b; } }; // 调用函数 sort(vec.begin(),vec.end(),Compare()); 5. map/multimap map支持[ ]运算符，multimap不支持[ ]运算符。在用法上没什么区别。 key 不允许修改 //头文件 #include // 创建 map map; // 使用{}赋值是从c++11开始的，因此编译器版本过低时会报错，如visual studio 2012 map map = { { 2015, \"Jim\" }, { 2016, \"Tom\" }, { 2017, \"Bob\" } }; map map; // 指定排序规则 // 迭代器 map::iterator it = map.begin(); map::iterator it = map.end(); it->first; // key it->second; // 值 // 添加key value pair state;// 能判断是否插入成功;插入key存在时，返回false state = map.insert(pair(1, \"student_one\")); state = map.insert(map::value_type (1, \"student_one\")); map[key] = value; // key存在就覆盖，key没有就创建 // 查找 // 关键字查询，找到则返回指向该关键字的迭代器，否则返回指向end的迭代器 // 根据map的类型，返回的迭代器为 iterator 或者 const_iterator iterator find (const key_type& k); const_iterator find (const key_type& k) const; // 删除 // 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器 iterator erase( iterator pos ); // 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1 size_t erase( const key_type& key ); // 删除一定范围内的元素，并返回一个指向下一元素的迭代器 iterator erase( const_iterator first, const_iterator last ); // 清空map，清空后的size为0 void clear(); // 查询map是否为空 bool empty(); // 查询map中键值对的数量 size_t size(); // 查询关键字为key的元素的个数，在map里结果非0即1 ，可用于检测key是否包含 size_t count( const Key& key ) const; 排序： > : 从大到小排序 : 从小到大排序，默认方式 map map 对 key 进行排序。 map 不允许对 key 进行修改，所以 operator()引用与函数必须为 const class Compare{ public: bool operator()(const string & a,const string & b) const { return a.c_str()[0] names; 6. set/multiset 搜索、移除和插入计算速度 O(log(n))。 set 通常以红黑树实现。 set不允许两个元素有相同值。 不能通过set的迭代器去修改set元素，原因是修改元素会破坏set组织。 : *it += 1 #include // 创建 set names; set names; // 指定排序规则 // 添加 pair::iterator, bool> ret = names.insert(name); // 删除 names.erease(name); names.clear(); // 查找，找不到返回 end() set::iterator it = names.find(name); // 迭代器 set::iterator it = names.begin(); set::iterator it = names.end(); *it; // 计数 names.count(name); names.size(); names.empty(); 排序： > : 从大到小排序 : 从小到大排序，默认方式 set 不允许对 key 进行修改，所以 operator()引用必须为 const class Compare{ public: bool operator()(const string & a,const string & b) const { return a.c_str()[0] names; 7. deque #include // 创建 deque que; // 首尾操作 que.push_back(item); que.pop_back(); que.push_front(); que.pop_back(); que.front(); que.back(); // 删除 que.erase(it); que.clear(); // 查找 没有查找 用 #include 库中的 find 8. 二叉堆 完全二叉树 父节点的编号为k，子左节点编号为2k，子右节点的编号为2k+1 子节点的编号为x，父节点的编号为 ⌊x/2⌋\\lfloor x/2 \\rfloor⌊x/2⌋ 从上往下最后一个父节点的编号为 ⌊n/2⌋\\lfloor n/2 \\rfloor⌊n/2⌋ ,nnn 总节点数 数组存储 最大二叉堆： 每个节点 >= 子节点 最小二叉堆： 每个节点 9. 并查集（union_find） 9.1. 概念 [!note|style:flat] 使用前提： 一堆独立的元素 问题与关于这些元素「能否动态连通」有关，即将问题转为「元素之间连没连通」。「连通」也可以理解为共性，等效。 并查集解题思路：想办法让元素「分门别类」，建立动态连通关系。 class UF { /* 将 p 和 q 连接 */ public void union(int p, int q); /* 判断 p 和 q 是否连通 */ public boolean connected(int p, int q); /* 返回图中有多少个连通分量 */ public int count(); /* 找根 */ public int findRoot(int q); } class UnionSet{ public: vector parents; vector weights; // 统计连通分量 int count; void initialize(int n){ for(int i = 0; i weights[rootB]) { parents[rootB] = rootA; weights[rootA] += weights[rootB]; }else{ parents[rootA] = rootB; weights[rootB] += weights[rootA]; } count--; } bool isConnect(int a,int b){ int rootA = findRoot(a); int rootB = findRoot(b); if (rootA == rootB) { return true; } return false; } }; [!note] 并查集：一个集合有多少元素毫不相关；一个集合中的两个元素是否连通。 连通分量：集合中毫不相关的元素有多少。比如上图为8。 连通： 自反：自己和自己连通 对称：两个元素互相连通 传递：a与b连通，b与c连通，则c与a之间也是连通的。 9.2. 基本实现 9.2.1. 数据结构 利用一个数组parent[]来储存集合元素，来实现一个图存储： 1）数组的索引为元素值； 2）数组的值为元素的父节点。 元素的初始存储形式： 9.2.2. 合并 [!tip] 将两个元素遍历到根节点 将两个根节点连接起来 void merge(int a,int b){ // 找根 int rootA = findRoot(a); int rootB = findRoot(b); if(rootA == rootB){ return; } // 连接 parents[rootA] = rootB; count--; } 9.2.3. 连通 [!tip] 将两个元素遍历到各自的根 对比根是否一样？连通：不连通 // 是否连通 bool isConnect(int a,int b){ // 查根 int rootA = findRoot(a); int rootB = findRoot(b); if (rootA == rootB) { return true; } return false; } 9.3. 平衡性优化 当合并两颗树时，将节点多的一颗树接到轻的树上时，就会造成树的生长不稳定，所以在接树的时候，需要对比两颗树的节点数，少数服从多数。 void connect(int a,int b){ // 找根 int rootA = findRoot(a); int rootB = findRoot(b); if(rootA == rootB){ return; } // 连接 if (weights[rootA] > weights[rootB]) { parents[rootB] = rootA; weights[rootA] += weights[rootB]; }else{ parents[rootA] = rootB; weights[rootB] += weights[rootA]; } count--; } 9.4. 路径压缩（最重要） [!note|style:flat] element != parents[element]，节点与父节点不一样，就能跳过父节节点，直达爷节点。由于父节点自己指向自己，两个节点时，不会越界。 // 查找 int findRoot(int element){ while (element != parents[element]) { // 把当前节点的父节点跳一级，实现路径压缩 parents[element] = parents[parents[element]]; element = parents[element]; } return element; } [!tip|style:flat] 压缩路径的优化性能较强与平衡性优化，平衡性优化可以不用写。 9.5. 判定合法算式 题目： 给一组[\"a==b\",\"b!=c\",\"c==a\"]的关系式，判断这些式子能否成立。 ==：当成两个元素连通 !=: 两个元素不通 "},"cpp/chapter/array_list_withNum.html":{"url":"cpp/chapter/array_list_withNum.html","title":"十、数组链表操作","keywords":"","body":"数组链表操作 1. 排序 1.1. 冒泡排序 稳定排序，排序之后，数据输入顺序不会乱掉 string str; for (int i = 0; i 1.2. 桶排序 桶排序可以实现稳定排序 int* in; // 构建一个桶 vector > bucket(amount,vector()); // 排序 for(int i=0; i 1.3. 快速排序 若要对nums[lo..hi] 进行排序，我们先找一个分界点 p，通过交换元素使得 nums[lo..p-1] 都小于等于 nums[p]，且 nums[p+1..hi] 都大于 nums[p]，然后递归地去 nums[lo..p-1] 和 nums[p+1..hi] 中寻找新的分界点，最后整个数组就被排序了。 2. 链表 2.1. 构建链表 在头部叠加 void appendNode(int val){ Node* newNode = new Node(val); if (this->head == NULL) { this->last = newNode; this->head = newNode; }else{ // 在头部叠加 newNode->next = this->head; this->head = newNode; } size++; } 在尾部增加 void pushNode(int val){ Node *newNode = new Node(val); if (this->head == NULL) { this->head = newNode; this->last = newNode; }else{ // 在尾部添加 this->last->next = newNode; this->last = newNode; } size ++; } 2.2. 逆向 2.2.1. 整体逆向: 靠递归的返回过程，完成反转 ListNode reverse(ListNode head) { // 深入的终止调节 if (head.next == null) return head; // 返回的链表的尾节点是 head.next ListNode last = reverse(head.next); // 在尾节点增加一个节点 head.next.next = head; // 断开之前方向的链接 head.next = null; return last; } 2.2.2. 从首开始的n个局部逆向 将n+1节点位置储存，通过上面递归进行逆向，最后把 n+1 节点接回去。 ListNode successor = null; // 记录第 n + 1 个节点 // 反转以 head 为起点的 n 个节点，返回新的头结点 ListNode reverseN(ListNode head, int n) { if (n == 1) { // 记录第 n + 1 个节点 successor = head.next; return head; } // 以 head.next 为起点，需要反转前 n - 1 个节点 ListNode last = reverseN(head.next, n - 1); head.next.next = head; // 让反转之后的尾节点 head 和后面的节点连起来 head.next = successor; return last; } 2.2.3. 对m到n的节点进行逆向: 找到对m-1节点进行记录，然后用上面方法逆向，然后接回去。 // 找到第m个节点，然后返回这个节点 ListNode reverseBetween(ListNode head, int m, int n) { // base case if (m == 1) { return reverseN(head, n); } // 前进到反转的起点触发 base case，n也用减 1 ，一会儿反转是按照总长度来的 head.next = reverseBetween(head.next, m - 1, n - 1); return head; } 2.3. 一块一块逆向 循环实现: 将当前节点，用头方向增长的方式，重新生成一个链表 void reverse(Node* head){ Node* inverseHead = NULL; Node* currentNode = head; Node* temp = NULL; this->last = currentNode; while ( currentNode != NULL) { // 由于还要用，临时存一下 temp = currentNode->next; // 将当前的节点组成新的链表，采用头部增长的方式 currentNode->next = inverseHead; inverseHead = currentNode; // 更新 currentNode = temp; } this->head = inverseHead; } 块逆向: 递归深入拆分块，回退拼接块 reverse(a, b): 翻转的区间为：[a,b) ListNode reverseKGroup(ListNode head, int k) { if (head == null) return null; // 区间 [a, b) 包含 k 个待反转元素 ListNode a, b; a = b = head; // 循环完毕后，b已经到了 a+k ，[a，b]中间间隔了 k+1 个节点了 for (int i = 0; i 3. 回文 3.1. 字符遍历找回文 string palindrome(string& s, int l, int r) { // 防止索引越界 while (l >= 0 && r 3.2. 判断链表是否是回文 最简单的办法就是，把原始链表反转存入一条新的链表，然后比较这两条链表是否相同。 // 左侧指针 ListNode left; boolean isPalindrome(ListNode head) { left = head; return traverse(head); } boolean traverse(ListNode right) { if (right == null) return true; boolean res = traverse(right.next); // 后序遍历代码 res = res && (right.val == left.val); left = left.next; return res; } 4. 双指针 4.1. 快慢指针 快慢指针一般都初始化指向链表的头结点head，前进时快指针fast在前，慢指针slow在后。 4.1.1. 判定链表中是否含有环 `fast`的移动速度为`slow`的两倍。 boolean hasCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) return true; } return false; } 4.1.2. 已知链表中含有环，返回这个环的起始位置 ListNode detectCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) break; } // 上面的代码类似 hasCycle 函数 slow = head; while (slow != fast) { fast = fast.next; slow = slow.next; } return slow; } fast一定比slow多走了k步，这多走的k步其实就是fast指针在环里转圈圈，所以k的值就是环长度的「整数倍」。 4.1.3. 链表的中间位置 ListNode middleNode(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; } // slow 就在中间位置 return slow; } 链表的长度是奇数，slow恰巧停在中点位置 链表的长度是偶数，slow最终的位置是中间偏右： 4.1.4. 寻找链表的倒数第n个元素 让快指针先走n步，然后快慢指针开始同速前进;这样当快指针走到链表末尾null时，慢指针所在的位置就是倒数第n个链表节点（n不会超过链表长度） ListNode removeNthFromEnd(ListNode head, int n) { ListNode fast, slow; fast = slow = head; // 快指针先前进 n 步 while (n-- > 0) { fast = fast.next; } if (fast == null) { // 如果此时快指针走到头了， // 说明倒数第 n 个节点就是第一个节点 return head.next; } // 让慢指针和快指针同步向前 while (fast != null && fast.next != null) { fast = fast.next; slow = slow.next; } // slow.next 就是倒数第 n 个节点，删除它 slow.next = slow.next.next; return head; 4.1.5. 有序数组/链表去重 数组nums[]有顺序，slow走在后面，快指针fast走在前面探路，比较nums[fast]与nums[slow]，找到不重复的元素就告诉slow并让slow前进一步。nums[0 slow]便是去重后的数组。 int removeDuplicates(int[] nums) { if (nums.length == 0) { return 0; } int slow = 0, fast = 0; while (fast ListNode deleteDuplicates(ListNode head) { if (head == null) return null; ListNode slow = head, fast = head; while (fast != null) { if (fast.val != slow.val) { // nums[slow] = nums[fast]; slow.next = fast; // slow++; slow = slow.next; } // fast++ fast = fast.next; } // 断开与后面重复元素的连接 slow.next = null; return head; } 注: 由于c++还需要对new的对象进行手动释放，所以可以用数组来储存链表节点，或者使用智能指针。 4.1.6. 删除目标元素，不改变数组顺序 不要求数组有序，如果fast遇到需要去除的元素，则直接跳过，否则就告诉slow指针，并让slow前进一步。nums[0 slow-1]是去除元素后的数组 int removeElement(int[] nums, int val) { int fast = 0, slow = 0; while (fast 4.1.7. 移动零 上一问题的变种 4.2. 左右指针 一般初始化为: left = 0, right = nums.length - 1 二分查找 翻转数组 双指针，升序列，求两数之和 4.2.1. 田忌赛马 struct Entry{ int index; int val; Entry(int index, int val) : index(index), val(val){ } Entry(){} }; class Compare{ public: bool operator()(const Entry & A,const Entry & B)const{ if (A.val > B.val) { return true; } return false; } }; void optinalSequence(const int* nums1,int* nums2,int n ){ vector target; vector option; for (int i = 0; i target[i].val) { nums2[target[i].index] = option[right]; right--; }else{ // 打不赢，就用小的凑数 nums2[target[i].index] = option[left]; left++; } } } 凌乱的数组先排序 left: 指向最小的一端 right: 指向最大的一段 "},"cpp/chapter/find_withNum.html":{"url":"cpp/chapter/find_withNum.html","title":"十一、目标查找","keywords":"","body":"查找问题 1. 二分法 1.1. 基本的二分搜索 while(left 一次搜索的区间是：[left, right] while(left 终止条件：left == right + 1: 就两种情况会终止，1）right减过头；2）left加过头 int binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 注意 while(left target) right = mid - 1; // 注意 } return -1; } [!note|style:flat] 注： nums = [1,2,2,2,3];targe = 2;找目标的边界，普通二分法无法实现。 1.2. 寻找左侧边界的二分搜索 while(left 一次搜索的区间是：[left, right] while(left 终止条件：left == right + 1: 就两种情况会终止，1）right减过头；2）left加过头 left = [0,nums.length] 返回值含义：nums中小于target的值的个数 nums循序排列，target在数组nums中。 int left_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left target) { right = mid - 1; } else if (nums[mid] == target) { // 别返回，锁定左侧边界 right = mid - 1; } } // 最后要检查 left 越界的情况，target值也不在数组中 if (left >= nums.length || nums[left] != target) return -1; return left; } 1.3. 寻找右侧边界的二分搜索 返回值含义：nums中大于target的值的个数 nums循序排列，target在数组nums中。 int right_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left target) { right = mid - 1; } else if (nums[mid] == target) { // 别返回，锁定右侧边界 left = mid + 1; } } // 最后要检查 right 越界的情况 if (right 注： while(left 结束条件为 left == right while(left 一次搜索的区间是：[left, right) while(left 决定了left = mid + 1;right = mid;下一次的搜索区间就是：[left,mid) [left, right)就确定了初始条件：left = 0, right = nums.length int right_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0, right = nums.length; while (left target) { right = mid; } } if(left == 0 || nums[left - 1] != target){ return -1; } return left - 1; // 注意 } 2. two sum 2.1. 问题 给一个数组和一个整数target，可以保证数组中存在两个数的和为target，返回这两个数的索引。 例: 输入: nums = [3,1,3,6],target = 6 返回数组: [0,2] 2.2. 双指针暴力枚举 void twoSum(int* nums,int target,int * out){ for(int i=0;i 2.3. 哈西表查询第二个值 void twoSumMap(int*nums,int n,int target,int* out){ // 存储 值-索引 map valIndex; for (int i = 0; i 0 && valIndex[other] != i) { out[0]=i; out[1]=valIndex[other]; return; } } } 2.4. 双指针，升序列，求两数之和 int[] twoSum(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left target) { right--; // 让 sum 小一点 } } return new int[]{-1, -1}; } 2.5. 输出所有不重复的组合 void twoSum(vector &nums,int target){ // 先排序 sort(nums.begin(),nums.end()); int left = 0; int right = nums.size() - 1; int temp; while(left target){ right --; }else if(sum == target){ cout 2.6. 3Sum 问题 sort(): 首先进行排序 从左向右依次遍历数组 nums[index] target =target - nums[index]: 将3sum问题转为2sum问题。 nums[index]还要去重复 vector > twoSum(vector &nums,int start,int target){ vector > out; int left = start; int right = nums.size() - 1; int temp; while(left target){ right --; }else if(sum == target){ out.push_back(vector()); out[out.size() - 1].push_back(nums[left]); out[out.size() - 1].push_back(nums[right]); // 左边重复 temp = nums[left]; while(left > threeSum(vector &nums,int target){ // 先排序 sort(nums.begin(),nums.end()); vector > out; int index = 0; int temp; while (index > res = twoSum(nums,index+1, target - nums[index]); // 去重复 temp = nums[index]; while (index & item : res){ item.push_back(temp); out.push_back(item); } } return out; } 3. 删除/查找数据O(1) 使用map存储索引，vector存储数据 查找: 通过map找索引，通过索引去vector拿数据 删除: 将最后一个元素与删除元素进行替换，修改map，然后再删除索引和数据 4. 区间问题 4.1. 解题技巧 端点排序：按照区间起点排序，或者先按照起点升序排序，若起点相同，则按照终点降序排序。 不降序，会出问题 作图：分别讨论一次涉及的循环区间，有哪些情况，防止漏掉。 区间关系条件得找对。 4.2. 区间覆盖问题 int removeCoveredIntervals(int[][] intvs) { // 按照起点升序排列，起点相同时降序排列 Arrays.sort(intvs, (a, b) -> { if (a[0] == b[0]) { return b[1] - a[1]; } return a[0] - b[0]; }); // 大区间 int left = intvs[0][0]; int right = intvs[0][1]; int res = 0; for (int i = 1; i = intv[1]) { res++; } // 情况二，找到相交区间 if (right >= intv[0] && right 4.3. 区间合并 struct Interval{ int left; int right; Interval(){} Interval(int left, int right){ this->left = left; this->right = right; } }; class Compare{ public: bool operator()(const Interval & a, const Interval & b)const{ if (a.left b.right) { return true; } } return false; } }; vector mergeIntervals(vector& intervals){ // 排序 sort(intervals.begin(), intervals.end(),Compare()); vector res; int left = intervals[0].left; int right = intervals[0].right; res.push_back(Interval(left, right)); for (int i = 1; i = left && curR = left && curL right){ // 相交 res.back().right = curR; right = curR; }else if(curL > right){ // 分离 left = curL; right = curR; res.push_back(Interval(left, right)); } } return res; } 4.4. 区间交集 归纳交集：!(l1 > r2 || r1 归纳指针移动条件：(r1 vector intersection(vector& inter1, vector& inter2){ // 先排序 sort(inter1.begin(), inter1.end(),Compare()); sort(inter2.begin(), inter2.end(),Compare()); // 区间指针 int index1=0,index2=0; int left,right; vector res; // 遍历区间 while (index1 r2 || r1 4.5. 给定两矩形，求相交面积 排序：矩形可以由两个点对角点表示，首先需要确定两个的位置 作图：判断相交关系 // 确保起点在下，终点在上 Rect getRect(int x1,int y1,int x2,int y2){ Rect A; A.xStart = min(x1,x2); A.yStart = min(y1,y2); A.xEnd = max(x1,x2); A.yEnd = max(y1,y2); return A; } int intersectionRect(Rect A,Rect B){ // 判断是否相交 if(!(A.xStart >= B.xEnd || A.xEnd = B.yEnd)){ Rect intersection; intersection.xStart = max(A.xStart,B.xStart); intersection.yStart = max(A.yStart,B.yStart); intersection.xEnd = min(A.xEnd,B.xEnd); intersection.yEnd = min(A.yEnd,B.yEnd); return (intersection.xEnd - intersection.xStart) * (intersection.yEnd - intersection.yStart); } return 0; } 5. 二分法威力加强 [!tip] 0. 求解该问题可以对一个单调函数区间暴力遍历 1. 解为一个单调函数里的某一值。 2. 单调函数可以根据一个状态，将区间划分为两半。 二分法找值： 单调：数组需要先排序 状态：和mid比大小 区间：mid的「左边」或者「右边」 5.1. 珂珂吃香蕉 calculateH(speed)单调函数，随speed增加而减小 (calculateH(nums,n,mid) 将speed区间划分为两半 int calculateH(const int* nums,int n, int speed){ int h = 0; for(int i = 0; i 0 ? 1 : 0); } return h; } int minSpeed(const int* nums,int n,int H){ // 最大的情况 int right = findMax(nums,n); int left = 1; while(left H){ left = mid + 1; } } return left; } 5.2. 运输货物 void findBorder(const vector& goods,int & left,int & right){ for(int item:goods){ left = max(left,item); right += item; } } int calculateDay(const vector& goods,int w){ int count = 0; int day = 0; for(int item:goods){ count += item; // 超重 if (count > w) { // 重置，并回退一个货物 count = item; day ++; } } // 没装完 if (count != 0) { day ++; } return day; } int minWeight(const vector& goods,int day){ int left = 0; int right = 0; // 寻找区间 findBorder(goods,left,right); while(left day){ left = mid + 1; } } return left; } 5.3. 分割数组的最大值 问题5.2的变种。 6. 滑动窗口 [!note|style:flat] 滑动窗口主要用于解决，在长序列上，不要求顺序，找子序列的各种问题，。 6.1. 模板 [!tip] 可以想象成一条虫子在一根线上从左向右蠕动。 先头动，搜寻问题的解，更新状态 后尾动，优化找到的解，更新状态。 int left = 0, right = 0; while (right /* 滑动窗口算法框架 */ void slidingWindow(string s, string t) { // 标记序列用 // window：标记主序列；need：标记子序列 unordered_map need, window; for (char c : t) need[c]++; // 窗的左右边界 int left = 0, right = 0; // 有效信息的标记值 int valid = 0; while (right [!warning|style:flat] window[]在扩展窗口时，最先更新。 window[]在收缩窗口时，最后更新。 6.2. 最小覆盖子串 string coveredSubsequences(const string &s,const string &t){ unordered_map windows; unordered_map need; // 标记字串 for(char ch : t){ need[ch]++; } int len = s.size() + 1; int start = len; int left = 0; int right = 0; int valid = 0; // 头挪动 while (right right - left){ len = right - left; start = left; } // 出去一个 char outch = s[left]; left++; if (need.count(outch) && windows[outch] == need[outch]) { valid--; } // 操作完毕再取消 windows[outch]--; } } if (len == s.size() + 1) { return \"\"; } return s.substr(start,len); } 6.3. 字符串排列 while (right = B.length()) { // 字符都找到了 if (valid == need.size()) { return true; } 。。。 } right - left >= B.length():使用>=，不满足条件时，还要缩小窗口。 bool substring(const string & S,const string & B){ unordered_map window,need; for(char ch:B){ need[ch]++; } int left = 0; int right = 0; int valid = 0; while (right 0) { window[ch]++; // 满足要求 if (window[ch] == need[ch]) { valid += 1; } } // 找到解的评判标准是：字符串长度 while (right - left >= B.length()) { if (valid == need.size()) { return true; } char ch = S[left]; left++; if (need.count(ch)) { if(window[ch] == need[ch]){ valid--; } window[ch]--; } } } return false; } 6.4. 找所有字母异位词 解题思路和6.3一样。 vector diffSubstring(const string& s1, const string& s2){ // 存储索引 vector starts; unordered_map need,window; for(char ch:s2){ need[ch]++; } int left=0; int right=0; int valid = 0; while(right = s2.length()) { if (valid == need.size()) { starts.push_back(left); } char ch = s1[left]; left++; if (need.count(ch)) { if (need[ch] == window[ch]) { valid--; } window[ch]--; } } } return starts; } 6.5. 最长无重复子串 int findMaxLen(const string& str){ unordered_map window; int left=0; int right=0; int maxLen = 0; while(right 1) { char out = str[left]; left++; window[out]--; } maxLen = max(maxLen,right - left); } return maxLen; } "},"cpp/chapter/binaryTree_withNum.html":{"url":"cpp/chapter/binaryTree_withNum.html","title":"十二、二叉树","keywords":"","body":"二叉树 1. 递归的逻辑 明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节。 以内部函数调用为分界，上部分是入栈，下部分是出栈 // 定义：count(root) 返回以 root 为根的树有多少节点 int count(TreeNode root) { // base case if (root == null) return 0; // 自己加上子树的节点数就是整棵树的节点数 return 1 + count(root.left) + count(root.right); } 2. 二叉树的操作逻辑 先搞清楚当前 root 节点「该做什么」(重点)以及「什么时候做」(前，中，后)，然后根据函数定义递归调用子节点。 /* 二叉树遍历框架 */ void traverse(TreeNode root) { // 前序遍历 traverse(root.left) // 中序遍历 traverse(root.right) // 后序遍历 } 3. 二叉树前，中，后序列化与反序列化 序列化储存形式：12#4 3,#表示空节点 改变「解析」和「序列化」位置，可以分别实现前，中，后。 深度优先搜索 struct Node{ int value; Node* left; Node* right; Node(){ left = nullptr; right = nullptr; } ~Node(){ if (left != nullptr) { delete left; } if (right != nullptr) { delete right; } } }; class BinaryTree{ private: const string nullStr = \"#\"; public: Node* deserialize(queue &nodes){ // 读取一个节点 string str = nodes.front(); nodes.pop(); // 到头了 if (str == nullStr) { return nullptr; } // 解析 Node* node = new Node(); node->value = stoi(str); // 解析左右节点 node->left = deserialize(nodes); node->right = deserialize(nodes); return node; } string serialize(Node* root){ // 节点到头了 if (root == nullptr) { return nullStr; } // 序列化 string str = to_string(root->value); // 序列化左右 str = str + serialize(root->left); str = str + serialize(root->right); return str; } }; 4. 二叉树层级遍历的序列化与反序列化 序列化: 递归的作用，1）将父节点输出；2)子节点入队；3）当父节点出队 string serializeProcess(Node* root){ if (nodeQueue.empty()) { return \"\"; } // 搜索到头 string str = \"\"; if (root == nullptr) { str = nullnode; }else{ str = to_string(root->value); // 子节点入队 nodeQueue.push(root->left); nodeQueue.push(root->right); } // 将当前节点弹出 nodeQueue.pop(); str = str + serializeProcess(nodeQueue.front()); return str; } string serialize(Node* root){ while (!nodeQueue.empty()) { nodeQueue.pop(); } // 初始化队列 nodeQueue.push(root); return serializeProcess(nodeQueue.front()); } 反序列化： 递归的作用，1）父节点出队；2）解析左右子节点；3）子节点入队 void deserializeProcess(queue& nodes){ if(nodes.empty()){ return; } // 取出一个父类 Node* parent = nodeQueue.front(); nodeQueue.pop(); string str = \"\"; Node* node = nullptr; // 取出左子节点 str = nodes.front(); nodes.pop(); if (str == nullnode) { node = nullptr; }else{ node = new Node(); node->value = stoi(str); nodeQueue.push(node); } parent->left = node; // 取出右子节点 str = nodes.front(); nodes.pop(); if (str == nullnode) { node = nullptr; }else{ node = new Node(); node->value = stoi(str); nodeQueue.push(node); } parent->right = node; deserializeProcess(nodes); } Node* deserialize(queue& nodes){ while (!nodeQueue.empty()) { nodeQueue.pop(); } if (nodes.front() == nullnode) { return nullptr; } Node* root = new Node(); root->value = stoi(nodes.front()); nodes.pop(); nodeQueue.push(root); deserializeProcess(nodes); return root; } 5. 翻转二叉树 void invertTree(Node * root){ if (root == nullptr) { return; } // 交换节点 Node* temp = root->left; root->left = root->right; root->right = temp; invertTree(root->left); invertTree(root->right); } 6. 连通完全二叉树一层的节点 // 主函数 Node connect(Node root) { if (root == null) return null; connectTwoNode(root.left, root.right); return root; } // 辅助函数 void connectTwoNode(Node node1, Node node2) { if (node1 == null || node2 == null) { return; } /**** 前序遍历位置 ****/ // 将传入的两个节点连接 node1.next = node2; // 连接相同父节点的两个子节点 connectTwoNode(node1.left, node1.right); connectTwoNode(node2.left, node2.right); // 连接跨越父节点的两个子节点 connectTwoNode(node1.right, node2.left); } [!tip|style:flat] 「将每两个相邻节点都连接起来」 7. 将二叉树变链表 将 root 的左子树和右子树拉平 将 root 的右子树接到左子树下方 将整个左子树作为右子树。 // 定义：将以 root 为根的树拉平为链表 void flatten(TreeNode root) { // base case if (root == null) return; flatten(root.left); flatten(root.right); /**** 后序遍历位置 ****/ // 1、左右子树已经被拉平成一条链表 TreeNode left = root.left; TreeNode right = root.right; // 2、将左子树作为右子树 root.left = null; root.right = left; // 3、将原先的右子树接到当前右子树的末端 TreeNode p = root; while (p.right != null) { p = p.right; } p.right = right; } 8. 构造最大二叉树 左右拆分找节点 Node* constructMaximumBinaryTree(int* nums,int left,int right){ if(left > right){ return nullptr; } // 找最大值 int max = nums[left]; int maxIndex = left; for (int i = left + 1; i value = max; node->left = constructMaximumBinaryTree(nums,left,maxIndex - 1); node->right = constructMaximumBinaryTree(nums,maxIndex + 1,right); return node; } 9. 通过「前序和中序」遍历结果构造二叉树 递归创建处理root节点 在中序中，找root节点位置 左右拆分，进行递归。 重点为preorder,inorder如何拆两半 。 两种序列，传参时，不能搞错了。 Node* fromPreIn(int* preorder,int preL,int preR,int* inorder,int inL,int inR){ if (preL > preR || inL > inR) { return nullptr; } // 根节点 Node* root = new Node(); root->value = preorder[preL]; // 中序中，找root所在位置 int index = 0; for ( index = inL; index value){ break; } } // 两个子节点 root->left = fromPreIn(preorder,preL + 1,preL + (index - inL), inorder,inL,index - 1); root->right = fromPreIn(preorder,preL + (index - inL) + 1,preR, inorder,index + 1,inR); return root; } 10. 通过「中序和后序」遍历结果构造二叉树 [!note|style:flat] 注意： postR - 1 root->left = fromPostIn(postorder,postL,postL + interval - 1, inorder,inL,index - 1); root->right = fromPostIn(postorder,postL+interval,postR - 1, inorder,index+1,inR); "},"cpp/chapter/dynamicProgram_withNum.html":{"url":"cpp/chapter/dynamicProgram_withNum.html","title":"十三、动态规划","keywords":"","body":"动态规划 1. 动态规划概念 动态规划问题的一般形式就是求最值。 重叠子问题: 最终点问题是由某一单步小问题的重复，这些 小问题的求解可能会重复计算。 最优子结构: 当前步骤的最优只与\"上一步\"有关。根据这个特点可以状态压缩 状态转移方程: 递推式，解决问题的核心。 [!note|style:flat] 认为dp[i][j-1]就是问题在状态i,j-1下的结果，dp[i-1][j-1]就是问题在状态i-1,j-1下的结果，其余之前的状态同理。 也就是说，抵达i,j状态之前，dp[][]已经将i,j状态之前的状态全部尝试了一遍，并得到了相应的结果。 1.1. 解题框架 明确 base case: 如何初始化dp[]；确定边界条件。 明确「状态」: 推进子问题向大问题演变的变量。就是dp[i]的游标i的含义。 明确「选择」: 可以使得由过去的状态i-1,i-2,i-3...向当前状态i推进的 「选择」。 定义 dp 数组/函数: dp值 = f（当前状态） dp函数: 参数就是上面说到的「状态」。函数的返回值就是「结果」。 dp[i] 数组：i为「状态」，「结果」为dp[i] # 2. 初始化 dp[] = init # 3. 边界条件 dp[0][0][...] = base # 4. 进行状态转移 for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 求最值(选择1，选择2...) 4.1. 流程方向 自顶向下: 从目标开始，把大问题拆解小问题，直到到初始条件。 暴力递归: 把大问题拆成小的，递归下去 备忘录递归: 算过的值记录下来，不在重复算 自底向上: 从初始开始，根据递推式，一步一步迭代，直到目标结束。 dp数组: 从初始状态，根据递推关系，算到目标状态，循环数组，不用递归。 4.2. 重复子问题的确定 dp[i][j] = min{ dp[i-1][j] + 1, dp[i][i-1] + 1, dp[i-1][j-1] + 1 }   当从dp[i-1][j-1]过度到dp[i][j]的求解有多种路径时，就存在解重叠的情况。采用备忘录和dp数组解决。 4.3. 状态遍历顺序 [!note|style:flat] 确定二维表dp[][]初始值 确定递推式dp[i][j]的依赖情况（上图左边） 根据依赖关系填充二维表，满足横向填充或者纵向填充 // i = 0, j = 0 的情况是边界条件，已经初始化好了。 for (int i = 1; i 5. 斐波那契级数 题目： 某人有一对兔子饲养在围果它们每个月生1对兔子，且新的兔子在第2个月后(3个月为周期)也是每个月生1对兔子,问一年后围墙中共有多少对兔子。 递推式： f(n)=f(n−1)+f(n−2) f(n) = f(n-1) + f(n - 2)f(n)=f(n−1)+f(n−2) 序列为：1，1，3，5，8，13，21，34，55，89。。。 6. 凑零钱问题 题目： 给你k种面值的硬币，面值分别为c1, c2 ... ck，每种硬币的数量无限，再给一个总金额amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1。 分析： [!tip] 状态： amount 能推荐问题递推，问题的结果由amount影响 选择： 每次「状态」的推进，由c1, c2 ... ck确定。 dp[amount]定义：dp[amount]表示，当总金额为amount时，最少硬币数为dp[aomunt] int coinChange(const int * coins,int n,int amount){ // 定义dp[i]: 状态为钱总数；结果为当前总价最少钱币数 // 初始化放入极端值,由于是求解最小，所以放入一个大值 vector dp(amount + 1,amount + 1); // 边界条件 dp[0] = 0; for(int i=2;i = coins[j]){ dp[i] = min(dp[i],dp[i - coins[j]] + 1); } } } // 找不到 if (dp[amount] == amount + 1) { return -1; } return dp[amount]; } 7. 子序列问题 7.1. 最长递增(递减)子序列 问题特征： [!note|style:flat] 首先给一组1维的长序列， 若是2维问题，看看能不能排序降为1维问题。 要求子序列具有「某种单调关系」 目标子序列是关系下的「最长子序列」 分析： [!tip] 状态： 当前查找的序列的以索引i结束 选择： 选择dp[i-1],dp[i-2]...确定dp[i]。 dp[i]定义： 以索引i结束的序列，最长子序列的长度dp[i] int lengthOfLIS(vector& seq){ vector dp(seq.size(),1); dp[0] = 1; // 状态从 1 索引开始 for(int i=1;i seq[j]){ dp[i] = max(dp[i],dp[j] + 1); } } } int max = 1; for(int item:dp){ if(item > max) max = item; } return max; } 7.2. 信封嵌套问题 7.2.1. 降维 [!note|style:flat] 嵌套问题是要求[w,h]「两个」数据均有「单调的大小」关系，属于2维问题。而递增子序列问题是1维问题。 将「2维问题」转「1维问题」可以使用「排序」，先确定一个维度的关系，然后就只用关心一个维度。 排序：对于[v1,v2]形式，一般优先v1升序，若v1相等，则v2降序 7.2.2. 问题求解 [!tip] 排序 : 保证对1维序列进行操作，两点（[v1，v2]）数据，先排序：v1升序，v2降序 状态： 当前查找的序列的以索引i结束 选择： 选择dp[i-1],dp[i-2]...确定dp[i]。 dp[i]定义： 以索引i结束的序列，最长子序列的长度dp[i] struct Envelope { int width; int height; bool greatThan(const Envelope& temp){ if (this->width > temp.width && this->height > temp.height) { return true; } return false; } }; int maxEnvelopeLen(vector &envelopes){ // width 升序，hight 降序 sort(envelopes.begin(), envelopes.end(),[](const Envelope & A, const Envelope & B)->bool{ if (A.width B.height){ return true; } } return false; }); vector dp(envelopes.size(),1); for(int i=0;i 7.3. 最小编辑距离 [!tip] 状态： 解决两个字符串的动态规划问题，一般都是用「两个指针」，即「两个状态」。 源头字符串的前j个字符，目标字符串的前i个字符。 选择： 删除，插入，替换，跳过 dp[i][j]定义： 目标字符串的前i个字符变为源头字符串的前j个字符，所做的小操作距离 插入： 目标字符串前i个字符与源字符串的前j-1个字符相同的情况，变当前状态i,j dp[i][j]=dp[i][j−1]+1 dp[i][j] = dp[i][j-1] + 1dp[i][j]=dp[i][j−1]+1 删除： 目标字符串前i-1个字符与源字符串的前j个字符相同的情况，变当前状态i,j dp[i][j]=dp[i−1][j]+1; dp[i][j] = dp[i-1][j] + 1;dp[i][j]=dp[i−1][j]+1; 替换： 目标字符串前i-1个字符与源字符串的前j-1个字符相同的情况，变当前状态i,j dp[i][j]=dp[i−1][j−1]+1; dp[i][j] = dp[i-1][j-1] + 1;dp[i][j]=dp[i−1][j−1]+1; > [!warning|style:flat] > **动态规划状态的迁移：永远是之前已经得出结论的状态，迁移到当前状态；根据`1.4`的状态遍历，之前的状态默认是已经提前都计算好，不必深究。** ```cpp int minDistance(const string & S,const string & T){ // 在S的j位置，在T的i位置时，操作数最小 vector > dp(T.length()+1,vector(S.length()+1,0)); // 初始化，当目标是空串时 for(int i=1;i ## 7.4. 最大子数组之和 [!tip] 状态： 数组的当前索引i 选择： 由于是「连续子数组」，那就只能和挨着的对比，即dp[i],dp[i-1] dp[i]定义： 以nums[i]为结尾的「最大子数组和」为dp[i] int maxSum(vector &nums){ // 初始化 vector dp(nums); for (int i = 1; i 7.5. 最长公共子序列问题 7.5.1. 算法 问题： 输入s1 = \"zabcde\", s2 = \"acez\"，它俩的最长公共子序列是lcs = \"ace\"，长度为 3，所以算法返回 3。 [!tip] 状态： 解决两个字符串的动态规划问题，一般都是用「两个指针」，即「两个状态」。 s1的前i个字符，s2的前j个字符。 选择： 当s1[i]==s2[j]时，dp[i-1][j-1] + 1；当s1[i]!=s2[j]时，要找一个目前最大子串长度值max(dp[i-1][j],dp[i][j-1])（有可能s1[i]子序列中，有可能s2[j]子序列中） dp[i][j]定义： 在s1的前i个字符，s2的前j个字符时，最大子序列的最大长度。 int maxPublicSub(const string& strA,const string& strB){ vector > dp(strB.size()+1,vector(strA.size()+1,0)); for (int i = 1; i 7.5.2. 字符串的删除操作 7.5.3. 最小 ASCII 删除和 [!tip] 状态： 解决两个字符串的动态规划问题，一般都是用「两个指针」，即「两个状态」。 s1的前i个字符，s2的前j个字符。 选择： 当s1[i]==s2[j]时，最小的是dp[i-1][j-1]；当s1[i]!=s2[j]时，要删除一个min(dp[i-1][j] + (int)strB[i-1],dp[i][j-1] + (int)strA[j-1])（有可能s1[i]在子序列中，有可能s2[j]在子序列中） dp[i][j]定义： 在s1的前i个字符，s2的前j个字符时，被删除的ascii码最小。 int minDeleteASCII(const string& strA,const string& strB){ vector > dp(strB.size()+1,vector(strA.size()+1,0)); // 当strA为空时 for (int i = 1; i 7.6. 子序列/子串问题总结 [!note|style:flat] 子串： dp[i]的定义，一般为 「以i结尾的连续子串。。。。」 子序列： dp[i]的定义，一般为 「从0到i位/置的子串。。。。」 涉及两个字符串/数组时，要用双状态 特例：一个数组，双指针 通过排序，可也把[v1,v2]转为子序列问题。 7.7. 特例：最长子序列回文 [!tip] 状态： i到j的子串。 选择： 当s1[i]==s1[j]时，增加两个dp[i][j] = dp[i+1][j-1] + 2;；当s1[i]!=s1[j]时，有一个可能在回文里，找最大的dp[i][j] = max(dp[i+1][j],dp[i][j-1]);（有可能s1[i]在子序列中，有可能s1[j]在子序列） dp[i][j]定义： i到j的子串，最大回文数为dp[i][j]。 初始： dp[][]的下半部不会涉及到，所以为0；当i==j时，dp[i][j]=1。 [!note|style:flat] 由于dp[i][j]与dp[i+1][j-1],dp[i+1][j],dp[i][j-1]有关，所以要重新设置遍历顺序。 int maxLenMirror(const string &str){ vector > dp(str.length(),vector(str.length(),0)); // 初始化 for (int i = 0; i =0; i--) { for (int j = i + 1; j "},"cpp/chapter/backtracking_withNum.html":{"url":"cpp/chapter/backtracking_withNum.html","title":"十四、回溯算法","keywords":"","body":"回溯算法 1. 框架 路径：记录做过具体的选择 标记：标记记录过的选择 选择列表：也就是你当前可以做的选择。 结束条件：也就是到达决策树底层，无法再做选择的条件。 result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」。 2. 全排列 void printAll(const vector & nums,vector &path,vector &book){ // 结束 if(path.size() == nums.size()){ string res = \"\"; for(int item:path){ res = to_string(item) + res; } cout 3. 全皇后 [!note|style:flat] 都用回溯算法，时间肯定不达标，放心大胆循环列条件。 bool isOk(vector & bord,int row ,int col){ // 检查行 for (int i = 0; i = 0; states[1] = row + 1 = 0; states[3] = col + 1 & bord,int count){ if(count == bord.size()){ for(string str:bord){ cout "},"cpp/chapter/monotoneStack_withNum.html":{"url":"cpp/chapter/monotoneStack_withNum.html","title":"十五、单调栈","keywords":"","body":"单调栈 1. 单调栈作用 根据当前入栈的值，栈内部会维持顺序（递增或递减）。 while (!s.empty() && s.top() : 比nums[i]小的都滚了，现在nums[i]最小，所以s是递减的 while (!s.empty() && s.top() >= nums[i]): 比nums[i]大的都滚了，现在nums[i]最大，所以s是递增的 void monotonousStack(int* nums,int n){ stack s; // 值入栈 for (int i = n-1; i >= 0; i--){ // 确保当前值在栈中是最小的 while (!s.empty() && s.top() 2. Next Greater Number 主要解决问题 Next Greater Number: 在当前数组中，比当前数更大的下一个数 for 循环: 要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。 while循环: 是把两个“高个”元素之间的元素排除 void nextGreater(int* nums,int n,int* out){ stack s; for (int i = n-1; i >= 0; i--){ while (!s.empty() && s.top() 3. 「循环」的Next Greater Number 将数组扩展一倍，然后用单调栈 4. 与 Next Greater Number之间的距离 void nextGreaterInterval(int* nums,int n,int* out){ // 栈中存放索引 stack s; for (int i = n-1; i >= 0; i--){ while (!s.empty() && nums[s.top()] >= nums[i]) { // 栈顶的值小于等于当前值，索引滚蛋 s.pop(); } // 栈空的：没找到；不为空：栈顶就是 if (s.empty()) { out[i] = -1; }else{ out[i] = s.top() - i; } // 当前的 i 入栈 s.push(i); } } 5. 无序数组，去除重复值 要去重 重字符串中的字符顺序不能打乱s中字符出现的相对顺序 在所有符合上一条要求的去重字符串中，字典序最小的作为最终结果 字典序：指从前到后比较两个字符串大小的方法。首先比较第1个字符，如果不同则第1个字符较小的字符串更小，一直这样子比较下去。 void rmDuplicate(const string & str){ // 字符计数 map count; // 储存最终序列，以当前字符，内部是单增的 stack s; // 是否重复 map inStack; // 计数 pair::iterator,bool> res; for(char ch:str){ res = count.insert(pair(ch,1)); if (res.second == false) { count[ch] += 1; } } for(char ch:str){ // 取出一个 count[ch] --; // 栈里面有，去重复 if (inStack.count(ch) && inStack[ch] == true) { continue; } // 最小字典序：s是单调增加的 while (!s.empty() && s.top() > ch) { // 后面已经没了，不能在弹出 if (count[s.top()] == 0) { break; } inStack[s.top()] = false; s.pop(); } s.push(ch); inStack[ch] = true; } string out = \"\"; while (!s.empty()) { out += s.top(); s.pop(); } for(int i = out.length() - 1;i >=0;i--){ cout map count: 记录存在个数 map inStack: 用来去重复 stack s: 用于存放结果，并利用单调栈的特性，实现最小字典序 "},"cpp/chapter/toollib_withNum.html":{"url":"cpp/chapter/toollib_withNum.html","title":"附录 工具库","keywords":"","body":"工具库 1. math #include // 绝对值 int abs(int); double fabs(double); // 四舍五入 double round(double); // 取整 double ceil(double num); // 向上取整 double floor(double num);// 向下取整 // 余数 double fmod(double num，double base); %; 只能用于int; 2. regex \\b : 字符边界 . : 除 \\n 以外所有字符 \\w : 等价于 [(0-9)(a-z)(A-Z)(_)] ，数字，字母，下划线 \\W : 上面取反 [^(0-9)(a-z)(A-Z)(_)] \\d : 数字 \\D : 上面取反 \\s : 空白符(空格，制表符，换行) \\S : 上面取反 regex_search : 只返回第一次匹配到的子串 上面的匹配字符，编程用时还要再加一个 `\\` #include // 定义表达式 regex reg(\"[a-z0-9]+\"); // 是否匹配 bool regex_match(string,regex);//全匹配 bool regex_search(string,regex);//子串匹配，只匹配第一次找到的 // 捕获 bool reg_search(string，smatch，regex); smatch.size(); //匹配到的个数: 表达式匹配 + 捕获匹配 smatch.str(0); // 整个正则匹配到的部分 smatch.str(i); // 0之后的，都是捕获部分 smatch.prefix().str(); // 未匹配的前部分 smatch.prefix().str();// 未匹配的后部分 3. 匿名函数 [!note] 只有c++11以上的编译器才支持。 [capture] (Parameters) ->return_type{ body; } capture: [] //未定义变量.试图在Lambda内使用任何外部变量都是错误的. [x, &y] //x 按值捕获, y 按引用捕获. [&] //用到的任何外部变量都隐式按引用捕获 [=] //用到的任何外部变量都隐式按值捕获 [&, x] //x显式地按值捕获. 其它变量按引用捕获 [=, &z] //z按引用捕获. 其它变量按值捕获 [!note|style:flat] [this](){this->;} 对于 this只能用值捕获。 parameters: 参数列表 return_type: 返回值 sort(vec.begin(),vec.end(),[](const Entry & A,const Entry & B) -> bool{ return A.val > B.val; }); "},"MySQL/mysql.html":{"url":"MySQL/mysql.html","title":"MySQL","keywords":"","body":"MySQL 笔记 "},"MySQL/chapter/introduction_withNum.html":{"url":"MySQL/chapter/introduction_withNum.html","title":"一、简介","keywords":"","body":"简介 1. 数据库系统（Database System，DBS） 定义： 是由数据库及其管理软件组成的系统。 组成： 数据库（DataBase) 数据库管理系统（DataBase Management System） 应用系统 数据库管理员（DataBase Administrator） 2. 数据库 (Database,DB) 定义： 数据仓库，存储数据的一个「文件」。 的数据随便存储，超过了就需要优化。 作用： 存储数据。 3. 数据库管理系统（DBMS） 3.1. 概念 定义： Database Manager System，一个操作数据库的「软件」，可以管理，维护，获取数据。数据存储在数据库文件里面，DBMS则是读写这个数据文件的软件。 作用： 操作管理数据库文件的软件。 3.2. 分类 关系型数据库SQL: 定义：通过表和表之间，行和列之间的关系进行数据存储。（类似 excel） 产品：MySQL，Oracle，Sql server，DB2 非关系型数据库NOSQL (Not Only SQL) 定义：对象储存，通过对象的自身属性来存储数据。（类似 Json） 产品：Redis，MongDB 4. MySQL简介 类型： 关系型数据库管理系统（Relational Database Management System）。 公司： 由瑞典 MySQL AB 公司开发，属于 Oracle 旗下产品。 特点： 开源免费，体积小，成本低，适用于大中小网站。 [!tip] MySQL安装 5. MySQL简单使用 启动MySQL服务 triangle@LEARN_FUCK:~/mysql$ net start mysql 停止MySQL服务 triangle@LEARN_FUCK:~/mysql$ net stop mysql 终端登录MySQL -p后面是直接跟密码，不要有空格。 triangle@LEARN_FUCK:~/mysql$ mysql -u root -p # -u [user]；-p [password] 清理干净MySQL triangle@LEARN_FUCK:~/mysql$ sc delete mysql 6. 规范数据库设计 6.1. 为毛要设计 [!tip] 当数据库比较复杂时，需要设计。 好的数据库： 节省内存空间 保证数据完整性 方便开发，维护 6.2. 数据库设计 分析需求：需要实现哪些功能，对应的需要创建哪些表。 表示实体：一张表里需要创建哪些字段。 实体关系：最后来分析表间字段的关系，能不说通，能不能实现功能。 7. 三大规范 第一范式 原子性：每一个字段都是不可在拆分的 第二范式 满足第一范式 每张表只描述一件事情。字段必须与主键完全相关，而不能与主键部分相关。 第三范式 满足第二范式 字段必须要与主键直接相关，不能间接相关。 [!note|style:flat] 规范与性能，有时不可兼得，性能更重要。 考虑到商业需求（用户体验，快），数据库计算性能更重要 故意增加字段，将join查询改为单表查询 增加一些计算列（索引） 参考博客：三大范式 "},"MySQL/chapter/foundation_withNum.html":{"url":"MySQL/chapter/foundation_withNum.html","title":"二、控制台操作","keywords":"","body":"控制台操作 1. 连接数据库 triangle@LEARN_FUCK:~/mysql$ mysql -u root -p 2. 退出连接 mysql>$ exit; 3. 修改密码 update mysql.user set authentication_string=password('新密码') where user='用户名' and Host ='localhost'; 4. 刷新权限 mysql>$ flush privileges; 5. 创建数据库 mysql>$ create database [数据库名]; 6. 删除数据库 mysql>$ drop database [数据库名]; 7. 显示所有数据库 mysql>$ show DATABASES; 8. 切换数据库 mysql>$ use [数据库名称] Database changed 9. 查看数据库中所有的表 先选中一个数据库，然后才能查看所选中的数据库中的表。 mysql>$ show tables; 10. 查看一个表中的内容 mysql>$ describe [表名]; "},"MySQL/chapter/operatorDB_withNum.html":{"url":"MySQL/chapter/operatorDB_withNum.html","title":"三、数据库、表操作","keywords":"","body":"数据库、表操作 1. SQL语法 1.1. 结尾 ; 表示一行代码解释。 1.2. 注释 -- 单行注释 /** * 多行注释 */ 1.3. 特殊名称 如果表名或者字段的名称和sql关键字冲突，或者带有特殊字符，这时候就需要用到 `` 。 create database `database`; 1.4. 命名 [!note|style:flat] SQL的关键字，字段名均不区分大小写。 2. 数据库需要操作的内容 [!note] 操作数据库 操作表 操作表中的数据 3. 操作数据库 3.1. 添加数据库 if not exists: 判断为真，才执行命令。 create database [if not exists] 数据库名; 3.2. 删除数据库 if exists: 判断为真，才执行。 drop database [if exists] 数据库; 3.3. 使用数据库 use `数据库名` 3.4. 字符集 create database `名称` character set utf8 collate utf8_general_ci; character set utf8：设定字符集 collate utf8_general_ci：校验字符集 4. 操作表 4.1. 数据库数据类型 4.1.1. 数值 类型 描述 字节 tinyint 最小的数 1 smallint 较小的数 2 mediumint 中等 3 int 标准 4 bigint 较大的 8 float 4 double 8 decimal 字符串的浮点数，防止浮点数丢失精度；金融行业 4.1.2. 字符串 类型 描述 字节 char 固定长度字符串，设定的长度全部用完 0 ~ 255 varchar 存储变长的字符串，设定的长度只是最大值 0 ~ 65535 tinytext 微型文本串，不能指定默认长度 0 ~ 255 text 文本串，存储可变长度的非Unicode数据，不能指定默认长度。 0 ~ 65535 4.1.3. 日期 类型 格式 描述 date YYYY-MM-DD 年月日 time hh:mm:ss 时分秒 datetime YYYY-MM-DD hh:mm:ss 年月日时分秒 timestamp 1970.1.1到现在的毫秒 时间戳 year 年 4.1.4. null [!note|style:flat] 不要使用null进行算数运算 字符串的空为''，并非null 4.2. 字段的属性 字段 作用 注意 unsigned 无符号整型 不能为负数 zerofill 未使用的字节，根据length进行0填充 Auto Inc 自增，在上一条记录上加一 1. 用来设计唯一的主键 2. 必须为整数 3. 可以设定初始值、步长 3. 超过类型最大值时，设置为最大值，并报错 not null 1. 勾选，不给对应元素复制，就会报错 2. 不选，不填值默认为null default 设置默认值 length 1.数值，显示的长度0001 2.char,varchar,字符的长度 4.3. 约束 create table [if not exists] `表明`( `列名` 类型(length) 字段约束, 表级约束 )[表类型] [字符集] [注释]; 4.3.1. 字段约束 约束 描述 not null 约束该字段的值不能为空 default 约束默认值 primary key 约束该字段的值具有唯一性，并且非空 unique [key/index] 约束该字段的值具有唯一性，可以为空 check 字段值是否有效 auto_increment 自增约束，数据删除后，值不会进行调整 4.3.2. 表级约束 约束 描述 primary key 约束该字段的值具有唯一性，并且非空 unique [key/index] 约束该字段的值具有唯一性，可以为空 check 字段值是否有效 FOREIGN KEY 用来确保数据的一致性，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值 [!note] 对于索引约束，除了primary key，其余都可以定义个索引名。 4.4. 表的列名(正式项目用) 列名 作用 id 主键 version 乐观锁 is_delete 伪删除，只是标记数据被删除，但是数组仍然储存在数据库中 gmt_create 创建时间 gmt_update 修改时间 4.5. 表的类型 项目 描述 MYISAM INNODB 事务 一段捆绑执行的业务逻辑 不支持 支持 行锁定 多用户，可对行操作进行锁定 不支持 支持 外键约束 建立主从表关系，确定数据一致性 不支持 支持 全文索引 支持 不支持 储存空间 较小 约为MYISAM的两倍 物理空间储存： 表都存储在指定数据库的文件夹下 INNODB 两个文件 .frm: 存储表的结构信息，在数据库文件夹下 ibdata1: 存储数据，与数据库文件夹同级 MYISAM 三个文件 .frm: 存储表的结构信息 .MYD：存储数据 .MYI：存储索引 4.6. 创建表 create table [if not exists] `表明`( `列名` 类型(length) [属性] [索引] [注释], .... `列名` 类型(length) [属性] [索引] [注释], primary key (`列名`) )[表类型] [字符集] [注释]; CREATE table if not exists `student`( `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '学号', `name` VARCHAR(10) NOT NULL DEFAULT '李华' COMMENT '名字', `sex` VARCHAR(2) NOT NULL DEFAULT '男' COMMENT '性别', `number` VARCHAR(11) NOT NULL DEFAULT '10086' COMMENT '电话', PRIMARY KEY(`id`) )engine=InnoDB charset=utf8 COMMENT='学生'; [!note|style:flat] 给定了not null属性后，就不能再设置default null。 4.7. 查看表 4.7.1. 查看表的列结构 describe `表名`; 4.7.2. 查看表的创建代码 show create table `表名`; 4.8. 修改表结构 4.8.1. 修改表名 alter table `表名` rename as `新表名`; 4.8.2. 增加字段（列） alter table `表名` add `列名` 类型名(length) [属性] [索引] [注释]; 4.8.3. 修改字段（列） 修改类型，约束（列属性）： alter table `表名` modify `列名` [类型，约束]; 可以重命名，修改类型，约束： alter table `表名` change `列名` `新列名` [类型，约束]; [!note|style:flat] 重新修改字段，[类型，约束]也会跟着以前修改掉，不指定就没有。 4.8.4. 修改表级别约束 增加： alter table `表名` add 约束 [`索引名`] (`字段`); 删除： alter table `表名` drop 约束 [`索引名` (`字段`)]; 4.8.5. 删除字段 alter table `表名` drop `列名`; 4.9. 删除表 drop table [if exists] `表名`; "},"MySQL/chapter/operatorData_withNum.html":{"url":"MySQL/chapter/operatorData_withNum.html","title":"四、数据操作","keywords":"","body":"数据操作 1. 外键 1.1. 概念 将两个表的字段关联起来，形成表间关系。 1.2. 外键的创建 [!note] 设置为外键的字段不能为主键 改键所参考的字段必须为主键 两个字段必须有相同的数据类型和约束 1.2.1. 生成表时创建 定义外键 添加约束 create table if not exists `grade`( `gradeId` int(10) not null AUTO_INCREMENT COMMENT '班级id', `name` VARCHAR(5) not null DEFAULT '一班' COMMENT '班级名', primary key (`gradeId`) )engine=INNODB charset=utf8; create table if not exists `student`( `id` int(11) not null auto_increment comment '主键', `name` VARCHAR(10) not null default '李华' comment '名字', `gradeId` int(10) not null comment '班级', primary key (`id`), -- 定义外键 key `FK_grade` (`gradeId`), -- 添加约束 constraint `FK_grade` FOREIGN key (`gradeId`) references `grade` (`gradeId`) )engine=INNODB charset=utf8; 1.2.2. 已经存在的表 alter table `student` add constraint `FK_gradeId` FOREIGN key (`gradeId`) REFERENCES `grade` (`gradeId`); 1.3. 外键表删除顺序 先删除「引用的表（从表）」 再删除「被引用的表（主表）」 1.4. 重点 [!note|style:flat] 不推荐使用外键在数据库层面关联两张表，而是利用代码在应用层对表进行关联。 2. DML语言(重点) 2.1. 概念 DML: 数据操作语言（Data Manipulation Language） 是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。 insert：增 delete：删 update：改 [!note|style:flat] 设置了not null的字段，在insert,update时，不能赋值为null。 2.2. 增 insert -- 对应字段插入一行数据 insert into `表名` ([`字段1`,`字段2`,...]) values (`值1`,`值2`,`值3`,...); -- 主键自增可以不用管，不写字段，值就默认与表的字段顺序一一对应 insert into `表名` values (`值1`,`值2`,`值3`,...); -- 对应字段，插入多行数据 insert into `表名` ([`字段1`,`字段2`,...]) values (`值1`,`值2`,`值3`,...), (`值1`,`值2`,`值3`,...), ... (`值1`,`值2`,`值3`,...); auto_increment: 带有自增属性的值，可以不用插入值。 insert into `student` (`name`,`age`) values ('小明','20'), ('小红','18'), ('马里奥','30'), ('路易吉','29'); 2.3. 改 update -- 修改指定位置的内容 update `表名` set `字段1`= value1,`字段2`= value2... where 条件; -- 修改整个字段的全部值 update `表名` set `字段`=value; value: 可以是具体的值，也可以是变量。 2.4. 删 2.4.1. delete 对数据是一行，一行的删除。 delete from `表名` where 条件; -- 清空表，不建议用 delete from `表名`; 2.4.2. truncate 清空表中所有数据。 truncate table `表名`; 2.4.3. 对比 相同：都能清空数据，不会修改表结构（alter table才能修能表结构）。 truncate不同： auto_increment可以归0 不会影响事务。 delete不同： INNODB：重启数据库后，auto_increment会归0（在内存中） MYISAM：重启后数据库后，auto_increment不会归0（在硬盘文件中） 3. DQL语言(重点) /* SQLyog Ultimate v13.1.1 (64 bit) MySQL - 5.7.33 : Database - school ********************************************************************* */ /*!40101 SET NAMES utf8 */; /*!40101 SET SQL_MODE = ''*/; /*!40014 SET @OLD_UNIQUE_CHECKS = @@UNIQUE_CHECKS, UNIQUE_CHECKS = 0 */; /*!40014 SET @OLD_FOREIGN_KEY_CHECKS = @@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS = 0 */; /*!40101 SET @OLD_SQL_MODE = @@SQL_MODE, SQL_MODE = 'NO_AUTO_VALUE_ON_ZERO' */; /*!40111 SET @OLD_SQL_NOTES = @@SQL_NOTES, SQL_NOTES = 0 */; CREATE DATABASE /*!32312 IF NOT EXISTS */`school` /*!40100 DEFAULT CHARACTER SET utf8 */; USE `school`; /*Table structure for table `grade` */ DROP TABLE IF EXISTS `grade`; CREATE TABLE `grade` ( `GradeID` INT(11) NOT NULL AUTO_INCREMENT COMMENT '年级编号', `GradeName` VARCHAR(50) NOT NULL COMMENT '年级名称', PRIMARY KEY (`GradeID`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8; /*Data for the table `grade` */ INSERT INTO `grade`(`GradeID`, `GradeName`) VALUES (1, '大一'), (2, '大二'), (3, '大三'), (4, '大四'), (5, '预科班'); /*Table structure for table `result` */ DROP TABLE IF EXISTS `result`; CREATE TABLE `result` ( `StudentNo` INT(4) NOT NULL COMMENT '学号', `SubjectNo` INT(4) NOT NULL COMMENT '课程编号', `ExamDate` DATETIME NOT NULL COMMENT '考试日期', `StudentResult` INT(4) NOT NULL COMMENT '考试成绩', KEY `SubjectNo` (`SubjectNo`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8; /*Data for the table `result` */ INSERT INTO `result`(`StudentNo`, `SubjectNo`, `ExamDate`, `StudentResult`) VALUES (1000, 1, '2013-11-11 16:00:00', 85), (1000, 2, '2013-11-12 16:00:00', 70), (1000, 3, '2013-11-11 09:00:00', 68), (1000, 4, '2013-11-13 16:00:00', 98), (1000, 5, '2013-11-14 16:00:00', 58); /*Table structure for table `student` */ DROP TABLE IF EXISTS `student`; CREATE TABLE `student` ( `StudentNo` INT(4) NOT NULL COMMENT '学号', `LoginPwd` VARCHAR(20) DEFAULT NULL, `StudentName` VARCHAR(20) DEFAULT NULL COMMENT '学生姓名', `Sex` TINYINT(1) DEFAULT NULL COMMENT '性别，0或1', `GradeId` INT(11) DEFAULT NULL COMMENT '年级编号', `Phone` VARCHAR(50) NOT NULL COMMENT '联系电话，允许为空', `Address` VARCHAR(255) NOT NULL COMMENT '地址，允许为空', `BornDate` DATETIME DEFAULT NULL COMMENT '出生时间', `Email` VARCHAR(50) NOT NULL COMMENT '邮箱账号允许为空', `IdentityCard` VARCHAR(18) DEFAULT NULL COMMENT '身份证号', PRIMARY KEY (`StudentNo`), UNIQUE KEY `IdentityCard` (`IdentityCard`), KEY `Email` (`Email`) ) ENGINE = MyISAM DEFAULT CHARSET = utf8; /*Data for the table `student` */ INSERT INTO `student`(`StudentNo`, `LoginPwd`, `StudentName`, `Sex`, `GradeId`, `Phone`, `Address`, `BornDate`, `Email`, `IdentityCard`) VALUES (1000, '123456', '张伟', 0, 2, '13800001234', '北京朝阳', '1980-01-01 00:00:00', 'text123@qq.com', '123456198001011234'), (1001, '123456', '赵强', 1, 3, '13800002222', '广东深圳', '1990-01-01 00:00:00', 'text111@qq.com', '123456199001011233'); /*Table structure for table `subject` */ DROP TABLE IF EXISTS `subject`; CREATE TABLE `subject` ( `SubjectNo` INT(11) NOT NULL AUTO_INCREMENT COMMENT '课程编号', `SubjectName` VARCHAR(50) DEFAULT NULL COMMENT '课程名称', `ClassHour` INT(4) DEFAULT NULL COMMENT '学时', `GradeID` INT(4) DEFAULT NULL COMMENT '年级编号', PRIMARY KEY (`SubjectNo`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8; /*Data for the table `subject` */ INSERT INTO `subject`(`SubjectNo`, `SubjectName`, `ClassHour`, `GradeID`) VALUES (1, '高等数学-1', 110, 1), (2, '高等数学-2', 110, 2), (3, '高等数学-3', 100, 3), (4, '高等数学-4', 130, 4), (5, 'C语言-1', 110, 1), (6, 'C语言-2', 110, 2), (7, 'C语言-3', 100, 3), (8, 'C语言-4', 130, 4), (9, 'Java程序设计-1', 110, 1), (10, 'Java程序设计-2', 110, 2), (11, 'Java程序设计-3', 100, 3), (12, 'Java程序设计-4', 130, 4), (13, '数据库结构-1', 110, 1), (14, '数据库结构-2', 110, 2), (15, '数据库结构-3', 100, 3), (16, '数据库结构-4', 130, 4), (17, 'C#基础', 130, 1); /*!40101 SET SQL_MODE = @OLD_SQL_MODE */; /*!40014 SET FOREIGN_KEY_CHECKS = @OLD_FOREIGN_KEY_CHECKS */; /*!40014 SET UNIQUE_CHECKS = @OLD_UNIQUE_CHECKS */; /*!40111 SET SQL_NOTES = @OLD_SQL_NOTES */; 3.1. 概念 DQL：数据查询语言（Data Query Language），「查」部分。 select：所有数据内容的查询 核心语句，使用频率最高。 3.2. 基础用法 3.2.1. 查询字段 *：表示查询全部字段 select `字段1`,`字段2`,... from `表名`; [!note|style:flat] 起了别名后，在之后的sql语句中，只能用别名。 3.2.2. as别名 可以给字段，表名给定一个别名，方便查看。 select `字段1` as 别名,`字段2` as 别名,... from `表名` as 别名; 3.2.3. 数据添加字符串 作用：给查询出来的数据中添加一个字符串。 select concat('字符串',`字段`,'字符串') as 别名 from `表名` as 别名; select CONCAT('科目名：',`SubjectName`,' fuck') from subject; 3.2.4. 查函数 select version(); 3.2.5. 数学计算 select 2/5 + 1 as 结果; 3.2.6. 查系统变量 select @@auto_increment_increment ; 3.2.7. 去重 distinct 作用：去除select查询出来的重复数据。 select distinct `字段1` as 别名,`字段2` as 别名,... from `表名` as 别名; 3.2.8. 选择性查询where select `字段1`,`字段2`,... from `表名` where 条件; 3.3. 表达式 数据库中的表达式： 文本值 列字段 Null 函数 计算表达式 系统变量 [!note|style:flat] 「表达式」都能使用 select 进行查询。 4. 条件过滤where 作用：检测对应条件的值。 where：查找成功，就执行指令；否则，不执行，并不会报错。 and/or：是连接两个条件的，对两个条件的结果进行判定。 ()：改变条件运算的优先级。 4.1. 一般条件 操作符 含义 = 等于 <>,!= 不等于 >, 大于，小于 >=, 不小于，不大于 and && 并 or ｜｜ 或 not ! 非 () 指定优先级 update `student` set `name`= '*' where (`age`=29) or (`age`=10); update `student` set `age` = 10 where `age` 4.2. 模糊条件 条件 描述 is null 是否为空 is not null 是否不为空 like 匹配式 1. %: 类似*，通配所有 2. _：一个字符 in (值1,值2,值3...) 在()中是否存在 between a and b 是否在[a,b]区间内 -- in 查找 SELECT * from result where `SubjectNo` in (3,4,1); -- 判断是否为 null select * from result where `ExamDate` is not null; -- like 匹配查找 select `StudentName`,`LoginPwd` from student WHERE `Address` like '北京%'; [!note|style:flat] 不能使用where 字段 = null，得用where 字段 is null in 与 = 结果集只有一个值时：A = B 与 A in ('B') 等价。 结果集只有一个值时：A = B or A = C 与A in (B,C)等价。 5. 联表查询 5.1. 概念 作用：对「两张表」进行联合查询，利用两张表的「相同的字段」进行连接，然后将查询结果作为「当作一张表」输出。 select a的字段,b的字段 (全部要输出的字段) from tableA [as] a 方式 join tableB [as] b on 两张表的连接条件字段 where 对最终合成表，再进行查询 ; [!note|style:flat] tableA , tableB：两张表根据写的先后顺序，具有左右之分。 tableA [as] a：as可以省略不写 join on：可以将查询的结果作为一张表，再与第三张表tableC进行链接 表名/别名.字段：可以对重复的字段名进行区别。 查询结果：以指定「连接方式」拼接出一个「基准表」；然后再对select字段的数据进行选择，并将将选择结果「当作一张新的表」；最后通过where筛选数据。 -- 所有需要查看的字段 select stu.`StudentNo`,`StudentName`,`StudentResult`,`SubjectName` -- 先连两张表 from student as stu LEFT join result as res on stu.StudentNo = res.StudentNo -- 连第三张表 inner join subject on subject.SubjectNo = res.SubjectNo -- 查询 where subject.SubjectName like 'c%'; 5.2. 连接方式 方式 字段 描述 inner from A iner join B on A.key = B.key A表与B表的key，以两边都有的key作为基准 left from A left join B on A.key = B.key A表与B表的key，以left表（A）的所有 A.key作为基准 right from A right join B on A.key = B.key A表与B表的key，以right表（B）的所有B.key作为基准 [!note|style:flat] 「连接方式」只是拼接出一个「包含两个表所有字段的基准表（同名字段，A.name与B.name，算两个字段）」，实际输出还得根据「select字段」来。 6. 自连查询（了解） 作用：将一张表，当作是两张表，然后进行联表查询。 要求：将表中的各项，根据层级关系显示出来。表： 查询结果： -- 建表 create table `schoolStruct`( `id` int(2) NOT NULL auto_increment comment 'id号', `pid` int(2) not NULL default 0 comment '父id', `name` varchar(100) default NULL comment '名称', primary key (`id`) )engine=innodb charset=utf8; -- 插入数据 insert into `schoolStruct` (`pid`,`name`) values (0,'南京理工大学'), (1,'能动院'), (1,'重点实验室'), (2,'802'), (2,'801'), (2,'808'); -- 自连查询 select p.`name` as '父',s.`name` as '子' from `schoolStruct` as p,`schoolStruct` as s where p.`id` = s.`pid`; 7. 分组 group by 作用：通过那一个字段进行分组，值一样的分为一组。 8. 组过滤 having [!note|style:flat] 分组之后的数据表，不能再使用where进行过滤，必须要用having。 select `subjectName`,AVG(`studentResult`) as `mean` ,max(`studentResult`),min(`studentResult`) from `result` r inner join `subject` sub on r.SubjectNo = sub.SubjectNo -- 所有数据进行过滤 where r.StudentResult > 20 group by sub.SubjectName -- 分组之后的数据进行过滤 having `mean` > 60 order by `mean` desc; 9. 排序order by 作用：对数据排序。 asc (ascending)：从上往下，从小到大 desc (descending)：从上往下，从大到小 select * from `表名` ORDER BY `排序字段` desc; 10. 分页limit 作用：部分显示表 limit 只能放最后。 limit：索引从 0 开始。 select * from `表名` limit 起始索引,显示行数; 11. 嵌套查询 对于where 条件，可以将条件修改为查询语句select。 /* c语言课成绩最好的，显示名字，学号 */ -- 最后显示的结果 select `studentNo`,`studentName` from `student` where `studentNo` = ( -- 对c语言成绩进行排序 select `studentNo` from `result` where `subjectNo` in ( -- 查询c语言课程 select `subjectNo` from `subject` where `subjectName` like 'c%' ) -- 排序 order by `StudentResult` desc -- 取出第一个 limit 0,1 ); [!note|style:flat] 该方法，只能用于最终结果都在一张表上的业务。 12. 函数 12.1. 常用函数 12.1.1. 数学 select abs(); -- 绝对值 select ceiling(); -- 向上取整 select floor(); -- 向下 select rand(); -- 随机数 0 ~ 1 select sign(); -- 数的符号 12.1.2. 字符串 select char_length(''); -- 字符串长度 select concat('','',...); -- 字符串拼接 select insert(src,pos,len,dest); -- 对src的字符串，将pos开始的len个字符，替换为dest select lower(''); -- 转小写 select upper(''); -- 转大写 12.1.3. 时间 select current_date(); -- 获取当前日期 select now(); -- 当前时间 select localtime(); -- 本地时间 select sysdate(); -- 系统时间 select year/month/hour(now()); -- 解析时间 12.1.4. 系统 select system_user(); select user(); select version(); 12.2. 聚合函数（重要） 函数 描述 count() 计数 sum() 求和 avg() 均值 max() 最大 min() 最小 12.2.1. count() count(字段)：会忽略所部的null。 count(*)：不会忽略null，返回表的「行数」。 count(1)：不会忽略null，返回表的「行数」。 12.3. MD5()加密 作用：增强算法复杂度，并且加密不可逆。 MD5的破解：MD5不可逆，只能先正向获取到加密内容，然后与要破解的加密内容进行对比，如果一样就破解成功。 -- 添加加密数据 insert into `password`(`name`,`pwd`) values ('小蓝',MD5('12345')), ('小红',MD5('23456')); -- 查询加密数据 select * from `password` where `name` = '小蓝' and `pwd` = MD5('12345'); 13. select总结 -- 显示结果 select [distinct] `字段1`,`字段2`,.... -- 表 from `表名1` [as] 别名1 -- 连接一个表 方式 join `表名2` [as] 别名2 on 别名1.`字段` = 别名2.`字段` -- 行数据过滤 where 过滤 -- 分组 group by `字段` -- 分组后，再行数据过滤 having 组过滤 -- 排序 order by `字段` asc/desc -- 显示内容 limit 起始索引,显示列数 ; [!warning|style:flat] 顺序不能乱！！！ "},"MySQL/chapter/transaction_withNum.html":{"url":"MySQL/chapter/transaction_withNum.html","title":"五、事务","keywords":"","body":"事务 1. 事务概念 [!note] 概念：一段业务逻辑，要么全部成功，要么全部失败，不允许某部分成功的情况。 代码实现：就是将一组SQL代码放到一个批次中执行。 2. ACID原则 参考博客：事务ACID理解 2.1. 介绍 概念 描述 原子性(atomicity) 整个过程要么全部成功，要么全部失败 一致性(consistency) 操作后与操作前，数据状态一致 隔离性(isolation) 多用户并发，不会相互影响 持久性(durability) 事务「提交」到数据库，数据库改变且不可逆(回滚无效) 事务没有提交到数据库，数据库恢复原状（数据库回滚） 2.2. 隔离所导致的问题 2.2.1. 脏读 A,B事务同时对「同一数据」进行操作，A在执行过程中并「还未提交」，B在「数据最开始的状态」上进行了修改并提交。这样B就对数据进行了脏读。 [!note|style:flat] 还有事务在运行时，进行数据获取，提交修改。 2.2.2. 不可重复读 在A事务运行时，多次对统一行数据进行「读取」。在此期间有其他事务「对数据修改」完成了提交，这样就会导致A事务的多次读取「数据值不一样」。 [!note|style:flat] 多次读同一位置的数据，值不一样 2.2.3. 幻读 在A事务运行时，多次对数据进行「读取」。在此期间有其他事务「添加了新数据修」完成了提交，这样A事务前后读取的「数据量不一样」。 [!note|style:flat] 多次读取某几行数据，突然多了一行数据 3. SQL操作 3.1. 事务自动提交 [!note|style:flat] MySQL默认开启自动提交。 -- 关闭 set autocommit = 0; -- 开启 set autocommit = 1; 3.2. 存档点 (了解) -- 存档点 savepoint 保存点 -- 回退存档点 rollback to 保存点 -- 删除存档点 release 保存点 [!note|style:flat] 事务失败了，这存档点也没啥用了。 3.3. 事务 -- 关闭自动提交 set autocommit = 0; -- 开启事务 start transaction 具体代码逻辑 -- 成功：提交 commit; -- 失败：回滚，恢复数据 rollback; -- 开启自动提交 set autocommit = 1; [!note|style:flat] 首先要关闭自动提交，事务执行完在开启。 在commit rollback后，就会关闭事务，所有特别关闭transaction 4. 行级锁 set autocommit = 0; -- 查询 select `字段` from `表名` where id = 1 for update -- 修改 update `表名` set `字段`=值 where id = 1 commit set autocommit = 1; [!note|style:flat] select for update：锁数据，为MySQL InnoDB 默认行级锁 一条 SQL 语句用不到「索引」是不会使用行级锁的，会使用表级锁把整张表锁住。 "},"MySQL/chapter/index_withNum.html":{"url":"MySQL/chapter/index_withNum.html","title":"六、索引","keywords":"","body":"索引 1. 索引简介 [!note] 作用：快速提升MySQL获取数据的速度。 效果：小数据的时候用处不大，大数据时效果十分明显。 缺点：表行数据的变化（insert, update, delete），建立在表列上的索引也会自动维护，一定程度上会使DML操作变慢；索引会占用磁盘额外的存储空间。 2. 索引分类 [!tip] primary key()：主键索引 唯一标识，主键不可重复 一张表最多只能有一个主键 unique key()：唯一索引 同一字段的数据不课重复 一张表可以可以表示多个字段 key/index：常规索引 默认的常规索引 fullText：全文索引 只有特定数据库类型支持(MYISAM) 查找的是文本中的关键词，主要用于全文检索 (字段1,字段2,..): 组合索引 将多个字段组合，建立起一个索引。 3. 索引指令 3.1. 显示表中所有的索引 show index from `表名`; 3.2. 索引的创建 3.2.1. 创建表时 create table `表名`( 字段。。。 primary key (`字段`), unique key `索引名`(`字段名`), key `索引名` (`字段名`), fullText key `索引名` (`字段名`) )engine=INNODB charset=utf8; 3.2.2. 添加表级别索引约束 alter table `表名` add unique key `索引名` (`字段名`); alter table `表名` add key `索引名` (`字段名`); alter table `表名` add fulltext key `索引名` (`字段名`); create 类型 index 索引名 on `表名`(`字段`); 3.3. 分析explain 作用：分析select查询语句使用情况。 explain select 查询语句; 4. 组合索引 create table `student`( `id` int(11) not null auto_increment, `name` varchar(20) not null, `address` varchar(20) not null, .... primary key (`id`,`name`), key `索引名`(`name`,`address`), unique `索引名` (`address`,`id`) )engine=INNODB charset=utf8; [!note] 索引都能使用组合索引。 组合索引最有顺序区别。 对于(id,name,address)组合索引，可以等效于「按照从左往右建立起来」的以下三种索引 id：where id= id,name：where id= AND name='' id,name,address：where id= AND name='' AND address='' 「联合索引」与「单列索引」列同时存在，使用「单列索引」。 5. 索引原则 [!note|style:flat] 索引不是越多越好 不需要对经常变动的数据添加索引 小数据不需要索引 索引添加到需要经常查询的字段上 索引优先级：主键索引，单列索引，组合索引 "},"MySQL/chapter/authority_withNum.html":{"url":"MySQL/chapter/authority_withNum.html","title":"七、权限管理","keywords":"","body":"权限管理 1. 创建用户 SQLyog软件： SQL命令： [!note|style:flat] 本质上，就是修改mysql数据下的user表。 -- 创建用户 create user 用户名 indentified by '密码'; -- 修改当前密码 set password=password(''); -- 修改指定用户密码 set password for 用户名=password('密码'); 2. 用户重命名 rename user 用户名 to 新名字; 3. 删除用户 drop user `用户名`; 4. 权限 给全部权限： -- 给指定表权限 grant all privileges on `数据库名`.`表名` to `用户`; -- 全部数据库与表 grant all privileges on *.* to `用户`; -- root 用户 GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION [!note|style:flat] all privileges：没有授权grant的权限。 查看权限： -- 查看用户的 show grants for 用户; -- 查看root的 show grants for root@ip地址; 撤销权限： rework all privileges on `数据库`.`表` from `用户`; "},"MySQL/chapter/backup_withNum.html":{"url":"MySQL/chapter/backup_withNum.html","title":"八、备份","keywords":"","body":"备份 1. 作用 [!note|style:flat] 防止删库跑路。 转移数据库 2. 直接拷贝文件 将硬盘上的数据库文件，直接备份。 3. 命令行 导出： triangle@LEARN_FUCK:~$ mysqldump -h[host] -u[user] -p[password] `数据库` `表1` `表2`> 备份路径/备份文件.sql 备份路径/备份文件.sql`)\"> triangle@LEARN_FUCK:~$ mysqldump -hlocalhost -uroot -p123456 school student > ~/a.sql ~/a.sql`)\"> 导入： mysql>$ use 数据库 # 导入表，先切换数据库 mysql>$ source 路径/a.sql triangle@LEARN_FUCK:~$ mysql -u[user] -p[password] [数据库] "},"linux/linux.html":{"url":"linux/linux.html","title":"Linux","keywords":"","body":"Linux 笔记 "},"linux/chapter/foundation_withNum.html":{"url":"linux/chapter/foundation_withNum.html","title":"一、原理知识","keywords":"","body":"1. 文件时间戳 [!note] 访问时间 (acces) （-atime 天，-amin 分钟）：文件被查看的时间，用户最近一次访问时间。 修改时间 (modify)（-mtime 天，-mmin 分钟）：「内容数据」被修改的最后一次修改时间。 变化时间 (change)（-ctime 天，-cmin 分钟）：状态时间，当文件的状态即文件的属性被改变是就会更改这个时间，例如文件系统中的links(链接数)，size(文件的大小)、文件的权限、blocks(文件的block数)； triangle@LEARN_FUCK:~$ stat command.md File: command.md Size: 1258 Blocks: 8 IO Block: 4096 regular file Device: 11h/17d Inode: 562949953511263 Links: 1 Access: (0777/-rwxrwxrwx) Uid: ( 1000/triangle) Gid: ( 1000/triangle) Access: 2021-09-08 10:21:03.394365400 +0800 Modify: 2021-09-08 10:11:44.128382200 +0800 Change: 2021-09-08 10:11:44.128382200 +0800 Birth: - 2. crontab定时 2.1. 简介 [!note] 作用：可以用来让系统定时调用某个指令。 原理：Linux下的任务调度分为两类：系统任务调度和用户任务调度。Linux系统任务是由 cron (crond) 这个系统服务来控制的，这个系统服务是默认启动的。 注意：crondtab配置会每分钟刷新一次。 2.2. 配置 配置文件 triangle@LEARN_FUCK:~$ cat /etc/crontab /* * /etc/crontab: system-wide crontab * Unlike any other crontab you don't have to run the `crontab' * command to install the new version when you edit this file * and files in /etc/cron.d. These files also have username fields, * that none of the other crontabs do. */ // crond任务运行的环境变量 SHELL=/bin/sh # 系统要使用哪个shell PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin # 系统执行命令的路径 // 定时命令配置 // m h dom mon dow user command 17 * * * * root cd / && run-parts --report /etc/cron.hourly 25 6 * * * root test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily ) 47 6 * * 7 root test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly ) 52 6 1 * * root test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly ) # 配置设置 [!tip|style:flat] *：取值范围内的所有值 /：一定时间间隔，如分钟字段为*/10，表示每10分钟执行1次 -：某个区间范围，如a - b表示[a,b] ,：分散的时间安排，如1,3,4 参考博客：crontab用法与实例 配置文件编辑 triangle@LEARN_FUCK:~$ vim /etc/crontab triangle@LEARN_FUCK:~$ crontab -e 3. 挂载 [!tip] fs表示file system triangle@LEARN_FUCK:~$ cat /etc/fstab // This file is edited by fstab-sync - see 'man fstab-sync' for details // Device Mount point filesystem parameters dump fsck LABEL=/ / ext3 defaults 1 1 LABEL=/boot /boot ext3 defaults 1 2 none /dev/pts devpts gid=5,mode=620 0 0 none /dev/shm tmpfs defaults 0 0 none /proc proc defaults 0 0 none /sys sysfs defaults 0 0 LABEL=SWAP-sda3 swap swap defaults 0 0 /dev/sdb1 /u01 ext3 defaults 1 2 UUID=18823fc1-2958-49a0-9f1e-e1316bd5c2c5 /u02 ext3 defaults 1 2 /dev/hdc /media/cdrom1 auto pamconsole,exec,noauto,managed 0 0 /dev/fd0 /media/floppy auto pamconsole,exec,noauto,managed 0 0 [!tip] 当系统启动的时候，会自动将此文件中指定的文件系统挂载到指定的目录。 Device 要挂载的分区或存储设备 Mount point 挂载点 filesystem 要挂载设备或是分区的文件系统类型;auto类型自动搜索，用于cd，DVD parameters 挂载参数 dump dump （0表示不进行dump备份，1代表每天进行dump备份，2代表不定日期的进行dump备份） pass fsck检测顺序 （其实是一个检查顺序，0代表不检查，1代表第一个检查，2后续.一般根目录是1，数字相同则同时检查） "},"linux/chapter/command_withNum.html":{"url":"linux/chapter/command_withNum.html","title":"二、指令","keywords":"","body":"指令 1. 文件目录 1.1. find [!tip] -size: 根据大小查找 -size +6k: 大于6k -size -10k: 小于10k -name: 根据名字查找 -type d: 文件夹 f: 文件 l: 软链接 -empty：查询空文件 忽略大小写 triangle@LEARN_FUCK:~$ find ./ -iname \"ReadMe.md\" 查询到文件然后执行指令 {}：代表find所查询到的内容 \\;：附加指令的结束标记 triangle@LEARN_FUCK:~$ find ./ -type f -exec python AutoNum.py {} \\; [!note|style:flat] -exec 执行语句 指令：可以理解为find查询到一个目标，然后执行一次，「执行语句」；「执行语句」执行类似for循环。 | xargs 执行语句指令：将管道符传入的stdout进行「参数化」处理，再塞给后面的「执行语句」；「执行语句」对「参数」批量执行一次。 时间查询 /var 目录下找出 90 天之内未被访问过的文件 triangle@LEARN_FUCK:~$ find /var -type f -atime -90 /home 目录下找出 120 天之前被修改过的文件 triangle@LEARN_FUCK:~$ find /home -type f -mtime +120 1.2. ls 显示文件名 triangle@LEARN_FUCK:~$ ls chapter linux.md 显示文件名与类型 triangle@LEARN_FUCK:~$ ls -F chapter/ linux.md* 显示完整路径 triangle@LEARN_FUCK:~$ ls -l total 0 drwxrwxrwx 1 triangle triangle 4096 Sep 7 21:34 chapter -rwxrwxrwx 1 triangle triangle 0 Sep 7 21:32 linux.md 1.3. mkdir triangle@LEARN_FUCK:~$ mkdir -p 路径 # -p：可以创建路径中没有的文件夹 1.4. du [!tip] du (disk usage): 查看文件夹和文件的磁盘占用 h a : 默认只显示文件夹，a会显示到具体文件 文件夹的大小 = 目录文件大小 + 文件夹内文件的大小; 数据块的大小 s （summarize） : 查看路径对于数据块的总大小 --max-depth= : 文件夹路径的层级 triangle@LEARN_FUCK:~$ du -h 8.0K ./chapter 8.0K . triangle@LEARN_FUCK:~$ du -ha 4.0K ./chapter/command.md 4.0K ./chapter/foundation.md 8.0K ./chapter 0 ./linux.md 8.0K 1.5. rm [!tip] --i：删除前询问 --f：强制删除 --r：递归 triangle@LEARN_FUCK:~$ rm -i linux.md rm: remove regular file 'linux.md'? n 1.6. 查看 命令 作用 cat 直接展开全部内容 tail 默认显示文件最后的 10 行文本 more 不能向上一行一行翻页，Ctrl b能回滚一页 less 在不加载整个文件的前提下显示文件内容，more的功能加强 添加行号 triangle@LEARN_FUCK:~$ cat -n linux.md 1 fuck you 2 linux 3 love linux triangle@LEARN_FUCK:~$ cat -n linux.md | less triangle@LEARN_FUCK:~$ cat -n linux.md | more [!note|style:flat] less more的行号可以通过cat添加 more重定向后，不能回滚 tail添加指定行 triangle@LEARN_FUCK:~$ tail -n 3 command.md > **作用：用于挂载Linux系统外的储存硬件，硬盘，u盘等，挂载到`linux`系统的一个文 件夹上，方便用户查看。** > - `mount 设备名(就是一文件路径) 挂载点(目标文件夹路径)`：挂载 > - `umount 设备名/挂载点`：卸载已经加载的文件系统 2. 硬件相关 2.1. df [!tip] df （disk free) : 查看硬盘整体使用情况 -h （human）: 会进行单位换算，方便人看 -i （inode）: 查看i节点 triangle@LEARN_FUCK:~$ df -h Filesystem Size Used Avail Use% Mounted on rootfs 125G 96G 30G 77% / none 125G 96G 30G 77% /dev none 125G 96G 30G 77% /run none 125G 96G 30G 77% /run/lock none 125G 96G 30G 77% /run/shm none 125G 96G 30G 77% /run/user tmpfs 125G 96G 30G 77% /sys/fs/cgroup C:\\ 125G 96G 30G 77% /mnt/c D:\\ 109G 6.5G 103G 6% /mnt/d E:\\ 121G 106G 15G 88% /mnt/e F:\\ 121G 97G 24G 81% /mnt/f G:\\ 226G 109G 118G 49% /mnt/g 2.2. mount [!tip] 作用：用于挂载Linux系统外的储存硬件，硬盘，u盘等，挂载到linux系统的一个文件夹上，方便用户查看。 mount 设备名(就是一文件路径) 挂载点(目标文件夹路径)：挂载 umount 设备名/挂载点：卸载已经加载的文件系统 3. 数据流处理 "}}